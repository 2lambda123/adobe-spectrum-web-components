{"version":3,"file":"d66333b3.js","sources":["../../../node_modules/@lit-labs/virtualizer/layouts/shared/SizeCache.js","../../../node_modules/@lit-labs/virtualizer/layouts/flow.js"],"sourcesContent":["export class SizeCache {\n    constructor(config) {\n        this._map = new Map();\n        this._roundAverageSize = false;\n        this.totalSize = 0;\n        if ((config === null || config === void 0 ? void 0 : config.roundAverageSize) === true) {\n            this._roundAverageSize = true;\n        }\n    }\n    set(index, value) {\n        const prev = this._map.get(index) || 0;\n        this._map.set(index, value);\n        this.totalSize += value - prev;\n    }\n    get averageSize() {\n        if (this._map.size > 0) {\n            const average = this.totalSize / this._map.size;\n            return this._roundAverageSize ? Math.round(average) : average;\n        }\n        return 0;\n    }\n    getSize(index) {\n        return this._map.get(index);\n    }\n    clear() {\n        this._map.clear();\n        this.totalSize = 0;\n    }\n}\n//# sourceMappingURL=SizeCache.js.map","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { SizeCache } from './shared/SizeCache.js';\nimport { BaseLayout, dim1 } from './shared/BaseLayout.js';\nexport const flow = (config) => Object.assign({\n    type: FlowLayout,\n}, config);\nfunction leadingMargin(direction) {\n    return direction === 'horizontal' ? 'marginLeft' : 'marginTop';\n}\nfunction trailingMargin(direction) {\n    return direction === 'horizontal' ? 'marginRight' : 'marginBottom';\n}\nfunction offset(direction) {\n    return direction === 'horizontal' ? 'xOffset' : 'yOffset';\n}\nfunction collapseMargins(a, b) {\n    const m = [a, b].sort();\n    return m[1] <= 0 ? Math.min(...m) : m[0] >= 0 ? Math.max(...m) : m[0] + m[1];\n}\nclass MetricsCache {\n    constructor() {\n        this._childSizeCache = new SizeCache();\n        this._marginSizeCache = new SizeCache();\n        this._metricsCache = new Map();\n    }\n    update(metrics, direction) {\n        var _a, _b;\n        const marginsToUpdate = new Set();\n        Object.keys(metrics).forEach((key) => {\n            const k = Number(key);\n            this._metricsCache.set(k, metrics[k]);\n            this._childSizeCache.set(k, metrics[k][dim1(direction)]);\n            marginsToUpdate.add(k);\n            marginsToUpdate.add(k + 1);\n        });\n        for (const k of marginsToUpdate) {\n            const a = ((_a = this._metricsCache.get(k)) === null || _a === void 0 ? void 0 : _a[leadingMargin(direction)]) || 0;\n            const b = ((_b = this._metricsCache.get(k - 1)) === null || _b === void 0 ? void 0 : _b[trailingMargin(direction)]) || 0;\n            this._marginSizeCache.set(k, collapseMargins(a, b));\n        }\n    }\n    get averageChildSize() {\n        return this._childSizeCache.averageSize;\n    }\n    get totalChildSize() {\n        return this._childSizeCache.totalSize;\n    }\n    get averageMarginSize() {\n        return this._marginSizeCache.averageSize;\n    }\n    get totalMarginSize() {\n        return this._marginSizeCache.totalSize;\n    }\n    getLeadingMarginValue(index, direction) {\n        var _a;\n        return ((_a = this._metricsCache.get(index)) === null || _a === void 0 ? void 0 : _a[leadingMargin(direction)]) || 0;\n    }\n    getChildSize(index) {\n        return this._childSizeCache.getSize(index);\n    }\n    getMarginSize(index) {\n        return this._marginSizeCache.getSize(index);\n    }\n    clear() {\n        this._childSizeCache.clear();\n        this._marginSizeCache.clear();\n        this._metricsCache.clear();\n    }\n}\nexport class FlowLayout extends BaseLayout {\n    constructor() {\n        super(...arguments);\n        /**\n         * Initial estimate of item size\n         */\n        this._itemSize = { width: 100, height: 100 };\n        /**\n         * Indices of children mapped to their (position and length) in the scrolling\n         * direction. Used to keep track of children that are in range.\n         */\n        this._physicalItems = new Map();\n        /**\n         * Used in tandem with _physicalItems to track children in range across\n         * reflows.\n         */\n        this._newPhysicalItems = new Map();\n        /**\n         * Width and height of children by their index.\n         */\n        this._metricsCache = new MetricsCache();\n        /**\n         * anchorIdx is the anchor around which we reflow. It is designed to allow\n         * jumping to any point of the scroll size. We choose it once and stick with\n         * it until stable. _first and _last are deduced around it.\n         */\n        this._anchorIdx = null;\n        /**\n         * Position in the scrolling direction of the anchor child.\n         */\n        this._anchorPos = null;\n        /**\n         * Whether all children in range were in range during the previous reflow.\n         */\n        this._stable = true;\n        this._measureChildren = true;\n        this._estimate = true;\n    }\n    // protected _defaultConfig: BaseLayoutConfig = Object.assign({}, super._defaultConfig, {\n    // })\n    // constructor(config: Layout1dConfig) {\n    //   super(config);\n    // }\n    get measureChildren() {\n        return this._measureChildren;\n    }\n    /**\n     * Determine the average size of all children represented in the sizes\n     * argument.\n     */\n    updateItemSizes(sizes) {\n        this._metricsCache.update(sizes, this.direction);\n        // if (this._nMeasured) {\n        // this._updateItemSize();\n        this._scheduleReflow();\n        // }\n    }\n    /**\n     * Set the average item size based on the total length and number of children\n     * in range.\n     */\n    // _updateItemSize() {\n    //   // Keep integer values.\n    //   this._itemSize[this._sizeDim] = this._metricsCache.averageChildSize;\n    // }\n    _getPhysicalItem(idx) {\n        var _a;\n        return (_a = this._newPhysicalItems.get(idx)) !== null && _a !== void 0 ? _a : this._physicalItems.get(idx);\n    }\n    _getSize(idx) {\n        const item = this._getPhysicalItem(idx);\n        return item && this._metricsCache.getChildSize(idx);\n    }\n    _getAverageSize() {\n        return this._metricsCache.averageChildSize || this._itemSize[this._sizeDim];\n    }\n    _estimatePosition(idx) {\n        const c = this._metricsCache;\n        if (this._first === -1 || this._last === -1) {\n            return (c.averageMarginSize +\n                idx * (c.averageMarginSize + this._getAverageSize()));\n        }\n        else {\n            if (idx < this._first) {\n                const delta = this._first - idx;\n                const refItem = this._getPhysicalItem(this._first);\n                return (refItem.pos -\n                    (c.getMarginSize(this._first - 1) || c.averageMarginSize) -\n                    (delta * c.averageChildSize + (delta - 1) * c.averageMarginSize));\n            }\n            else {\n                const delta = idx - this._last;\n                const refItem = this._getPhysicalItem(this._last);\n                return (refItem.pos +\n                    (c.getChildSize(this._last) || c.averageChildSize) +\n                    (c.getMarginSize(this._last) || c.averageMarginSize) +\n                    delta * (c.averageChildSize + c.averageMarginSize));\n            }\n        }\n    }\n    /**\n     * Returns the position in the scrolling direction of the item at idx.\n     * Estimates it if the item at idx is not in the DOM.\n     */\n    _getPosition(idx) {\n        var _a;\n        const item = this._getPhysicalItem(idx);\n        const { averageMarginSize } = this._metricsCache;\n        return idx === 0\n            ? (_a = this._metricsCache.getMarginSize(0)) !== null && _a !== void 0 ? _a : averageMarginSize\n            : item\n                ? item.pos\n                : this._estimatePosition(idx);\n    }\n    _calculateAnchor(lower, upper) {\n        if (lower <= 0) {\n            return 0;\n        }\n        if (upper > this._scrollSize - this._viewDim1) {\n            return this.items.length - 1;\n        }\n        return Math.max(0, Math.min(this.items.length - 1, Math.floor((lower + upper) / 2 / this._delta)));\n    }\n    _getAnchor(lower, upper) {\n        if (this._physicalItems.size === 0) {\n            return this._calculateAnchor(lower, upper);\n        }\n        if (this._first < 0) {\n            return this._calculateAnchor(lower, upper);\n        }\n        if (this._last < 0) {\n            return this._calculateAnchor(lower, upper);\n        }\n        const firstItem = this._getPhysicalItem(this._first), lastItem = this._getPhysicalItem(this._last), firstMin = firstItem.pos, lastMin = lastItem.pos, lastMax = lastMin + this._metricsCache.getChildSize(this._last);\n        if (lastMax < lower) {\n            // Window is entirely past physical items, calculate new anchor\n            return this._calculateAnchor(lower, upper);\n        }\n        if (firstMin > upper) {\n            // Window is entirely before physical items, calculate new anchor\n            return this._calculateAnchor(lower, upper);\n        }\n        // Window contains a physical item\n        // Find one, starting with the one that was previously first visible\n        let candidateIdx = this._firstVisible - 1;\n        let cMax = -Infinity;\n        while (cMax < lower) {\n            const candidate = this._getPhysicalItem(++candidateIdx);\n            cMax = candidate.pos + this._metricsCache.getChildSize(candidateIdx);\n        }\n        return candidateIdx;\n    }\n    /**\n     * Updates _first and _last based on items that should be in the current\n     * viewed range.\n     */\n    _getActiveItems() {\n        if (this._viewDim1 === 0 || this.items.length === 0) {\n            this._clearItems();\n        }\n        else {\n            this._getItems();\n        }\n    }\n    /**\n     * Sets the range to empty.\n     */\n    _clearItems() {\n        this._first = -1;\n        this._last = -1;\n        this._physicalMin = 0;\n        this._physicalMax = 0;\n        const items = this._newPhysicalItems;\n        this._newPhysicalItems = this._physicalItems;\n        this._newPhysicalItems.clear();\n        this._physicalItems = items;\n        this._stable = true;\n    }\n    /*\n     * Updates _first and _last based on items that should be in the given range.\n     */\n    _getItems() {\n        var _a, _b;\n        const items = this._newPhysicalItems;\n        this._stable = true;\n        let lower, upper;\n        // The anchorIdx is the anchor around which we reflow. It is designed to\n        // allow jumping to any point of the scroll size. We choose it once and\n        // stick with it until stable. first and last are deduced around it.\n        // If we have a pinned item, we anchor on it\n        if (this.pin !== null) {\n            const { index } = this.pin;\n            this._anchorIdx = index;\n            this._anchorPos = this._getPosition(index);\n        }\n        // Determine the lower and upper bounds of the region to be\n        // rendered, relative to the viewport\n        lower = this._scrollPosition - this._overhang; //leadingOverhang;\n        upper = this._scrollPosition + this._viewDim1 + this._overhang; // trailingOverhang;\n        if (upper < 0 || lower > this._scrollSize) {\n            this._clearItems();\n            return;\n        }\n        // If we are scrolling to a specific index or if we are doing another\n        // pass to stabilize a previously started reflow, we will already\n        // have an anchor. If not, establish an anchor now.\n        if (this._anchorIdx === null || this._anchorPos === null) {\n            this._anchorIdx = this._getAnchor(lower, upper);\n            this._anchorPos = this._getPosition(this._anchorIdx);\n        }\n        let anchorSize = this._getSize(this._anchorIdx);\n        if (anchorSize === undefined) {\n            this._stable = false;\n            anchorSize = this._getAverageSize();\n        }\n        const anchorLeadingMargin = (_a = this._metricsCache.getMarginSize(this._anchorIdx)) !== null && _a !== void 0 ? _a : this._metricsCache.averageMarginSize;\n        const anchorTrailingMargin = (_b = this._metricsCache.getMarginSize(this._anchorIdx + 1)) !== null && _b !== void 0 ? _b : this._metricsCache.averageMarginSize;\n        if (this._anchorIdx === 0) {\n            this._anchorPos = anchorLeadingMargin;\n        }\n        if (this._anchorIdx === this.items.length - 1) {\n            this._anchorPos = this._scrollSize - anchorTrailingMargin - anchorSize;\n        }\n        // Anchor might be outside bounds, so prefer correcting the error and keep\n        // that anchorIdx.\n        let anchorErr = 0;\n        if (this._anchorPos + anchorSize + anchorTrailingMargin < lower) {\n            anchorErr = lower - (this._anchorPos + anchorSize + anchorTrailingMargin);\n        }\n        if (this._anchorPos - anchorLeadingMargin > upper) {\n            anchorErr = upper - (this._anchorPos - anchorLeadingMargin);\n        }\n        if (anchorErr) {\n            this._scrollPosition -= anchorErr;\n            lower -= anchorErr;\n            upper -= anchorErr;\n            this._scrollError += anchorErr;\n        }\n        items.set(this._anchorIdx, { pos: this._anchorPos, size: anchorSize });\n        this._first = this._last = this._anchorIdx;\n        this._physicalMin = this._anchorPos - anchorLeadingMargin;\n        this._physicalMax = this._anchorPos + anchorSize + anchorTrailingMargin;\n        while (this._physicalMin > lower && this._first > 0) {\n            let size = this._getSize(--this._first);\n            if (size === undefined) {\n                this._stable = false;\n                size = this._getAverageSize();\n            }\n            let margin = this._metricsCache.getMarginSize(this._first);\n            if (margin === undefined) {\n                this._stable = false;\n                margin = this._metricsCache.averageMarginSize;\n            }\n            this._physicalMin -= size;\n            const pos = this._physicalMin;\n            items.set(this._first, { pos, size });\n            this._physicalMin -= margin;\n            if (this._stable === false && this._estimate === false) {\n                break;\n            }\n        }\n        while (this._physicalMax < upper && this._last < this.items.length - 1) {\n            let size = this._getSize(++this._last);\n            if (size === undefined) {\n                this._stable = false;\n                size = this._getAverageSize();\n            }\n            let margin = this._metricsCache.getMarginSize(this._last);\n            if (margin === undefined) {\n                this._stable = false;\n                margin = this._metricsCache.averageMarginSize;\n            }\n            const pos = this._physicalMax;\n            items.set(this._last, { pos, size });\n            this._physicalMax += size + margin;\n            if (!this._stable && !this._estimate) {\n                break;\n            }\n        }\n        // This handles the cases where we were relying on estimated sizes.\n        const extentErr = this._calculateError();\n        if (extentErr) {\n            this._physicalMin -= extentErr;\n            this._physicalMax -= extentErr;\n            this._anchorPos -= extentErr;\n            this._scrollPosition -= extentErr;\n            items.forEach((item) => (item.pos -= extentErr));\n            this._scrollError += extentErr;\n        }\n        if (this._stable) {\n            this._newPhysicalItems = this._physicalItems;\n            this._newPhysicalItems.clear();\n            this._physicalItems = items;\n        }\n    }\n    _calculateError() {\n        if (this._first === 0) {\n            return this._physicalMin;\n        }\n        else if (this._physicalMin <= 0) {\n            return this._physicalMin - this._first * this._delta;\n        }\n        else if (this._last === this.items.length - 1) {\n            return this._physicalMax - this._scrollSize;\n        }\n        else if (this._physicalMax >= this._scrollSize) {\n            return (this._physicalMax -\n                this._scrollSize +\n                (this.items.length - 1 - this._last) * this._delta);\n        }\n        return 0;\n    }\n    // TODO: Can this be made to inherit from base, with proper hooks?\n    _reflow() {\n        const { _first, _last, _scrollSize, _firstVisible, _lastVisible } = this;\n        this._updateScrollSize();\n        this._setPositionFromPin();\n        this._getActiveItems();\n        this._updateVisibleIndices();\n        if (this._scrollSize !== _scrollSize) {\n            this._emitScrollSize();\n        }\n        if (this._first !== _first ||\n            this._last !== _last ||\n            this._firstVisible !== _firstVisible ||\n            this._lastVisible !== _lastVisible) {\n            this._emitRange();\n        }\n        if (!(this._first === -1 && this._last === -1)) {\n            this._emitChildPositions();\n        }\n        if (this._scrollError !== 0) {\n            this._emitScrollError();\n        }\n        if ((this._first === -1 && this._last == -1) ||\n            (this._first === _first && this._last === _last)) {\n            this._resetReflowState();\n        }\n    }\n    _resetReflowState() {\n        this._anchorIdx = null;\n        this._anchorPos = null;\n        this._stable = true;\n    }\n    _updateScrollSize() {\n        const { averageMarginSize } = this._metricsCache;\n        this._scrollSize = Math.max(1, this.items.length * (averageMarginSize + this._getAverageSize()) +\n            averageMarginSize);\n    }\n    /**\n     * Returns the average size (precise or estimated) of an item in the scrolling direction,\n     * including any surrounding space.\n     */\n    get _delta() {\n        const { averageMarginSize } = this._metricsCache;\n        return this._getAverageSize() + averageMarginSize;\n    }\n    /**\n     * Returns the top and left positioning of the item at idx.\n     */\n    _getItemPosition(idx) {\n        var _a;\n        return {\n            [this._positionDim]: this._getPosition(idx),\n            [this._secondaryPositionDim]: 0,\n            [offset(this.direction)]: -((_a = this._metricsCache.getLeadingMarginValue(idx, this.direction)) !== null && _a !== void 0 ? _a : this._metricsCache.averageMarginSize),\n        };\n    }\n    /**\n     * Returns the height and width of the item at idx.\n     */\n    _getItemSize(idx) {\n        return {\n            [this._sizeDim]: this._getSize(idx) || this._getAverageSize(),\n            [this._secondarySizeDim]: this._itemSize[this._secondarySizeDim],\n        };\n    }\n    _viewDim2Changed() {\n        this._metricsCache.clear();\n        this._scheduleReflow();\n    }\n}\n//# sourceMappingURL=flow.js.map"],"names":["SizeCache","constructor","config","this","_map","Map","_roundAverageSize","totalSize","roundAverageSize","set","index","value","prev","get","averageSize","size","average","Math","round","getSize","clear","flow","Object","assign","type","FlowLayout","leadingMargin","direction","trailingMargin","collapseMargins","a","b","sort","m","min","max","MetricsCache","_childSizeCache","_marginSizeCache","_metricsCache","update","metrics","_a","_b","marginsToUpdate","keys","forEach","key","k","Number","dim1","add","averageChildSize","totalChildSize","averageMarginSize","totalMarginSize","getLeadingMarginValue","getChildSize","getMarginSize","BaseLayout","super","arguments","_itemSize","width","height","_physicalItems","_newPhysicalItems","_anchorIdx","_anchorPos","_stable","_measureChildren","_estimate","updateItemSizes","sizes","_scheduleReflow","_getPhysicalItem","idx","_getSize","_getAverageSize","_sizeDim","_estimatePosition","c","_first","_last","delta","pos","_getPosition","item","_calculateAnchor","lower","upper","_scrollSize","_viewDim1","items","length","floor","_delta","_getAnchor","firstItem","lastItem","firstMin","candidateIdx","_firstVisible","cMax","Infinity","_getActiveItems","_clearItems","_getItems","_physicalMin","_physicalMax","pin","_scrollPosition","_overhang","anchorSize","undefined","anchorLeadingMargin","anchorTrailingMargin","anchorErr","_scrollError","margin","_calculateError","extentErr","_reflow","_lastVisible","_updateScrollSize","_setPositionFromPin","_updateVisibleIndices","_emitScrollSize","_emitRange","_emitChildPositions","_emitScrollError","_resetReflowState","_getItemPosition","_positionDim","_secondaryPositionDim","_getItemSize","_secondarySizeDim","_viewDim2Changed"],"mappings":"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"}
{"version":3,"file":"75e5b9f4.js","sources":["../../../node_modules/lit-html/directives/repeat.js","../../../node_modules/@lit-labs/virtualizer/polyfillLoaders/ResizeObserver.js","../../../node_modules/@lit-labs/virtualizer/Virtualizer.js"],"sourcesContent":["import{noChange as e}from\"../lit-html.js\";import{directive as s,Directive as t,PartType as r}from\"../directive.js\";import{getCommittedValue as l,setChildPartValue as o,insertPart as i,removePart as n,setCommittedValue as f}from\"../directive-helpers.js\";\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst u=(e,s,t)=>{const r=new Map;for(let l=s;l<=t;l++)r.set(e[l],l);return r},c=s(class extends t{constructor(e){if(super(e),e.type!==r.CHILD)throw Error(\"repeat() can only be used in text expressions\")}dt(e,s,t){let r;void 0===t?t=s:void 0!==s&&(r=s);const l=[],o=[];let i=0;for(const s of e)l[i]=r?r(s,i):i,o[i]=t(s,i),i++;return{values:o,keys:l}}render(e,s,t){return this.dt(e,s,t).values}update(s,[t,r,c]){var d;const a=l(s),{values:p,keys:v}=this.dt(t,r,c);if(!Array.isArray(a))return this.ut=v,p;const h=null!==(d=this.ut)&&void 0!==d?d:this.ut=[],m=[];let y,x,j=0,k=a.length-1,w=0,A=p.length-1;for(;j<=k&&w<=A;)if(null===a[j])j++;else if(null===a[k])k--;else if(h[j]===v[w])m[w]=o(a[j],p[w]),j++,w++;else if(h[k]===v[A])m[A]=o(a[k],p[A]),k--,A--;else if(h[j]===v[A])m[A]=o(a[j],p[A]),i(s,m[A+1],a[j]),j++,A--;else if(h[k]===v[w])m[w]=o(a[k],p[w]),i(s,a[j],a[k]),k--,w++;else if(void 0===y&&(y=u(v,w,A),x=u(h,j,k)),y.has(h[j]))if(y.has(h[k])){const e=x.get(v[w]),t=void 0!==e?a[e]:null;if(null===t){const e=i(s,a[j]);o(e,p[w]),m[w]=e}else m[w]=o(t,p[w]),i(s,a[j],t),a[e]=null;w++}else n(a[k]),k--;else n(a[j]),j++;for(;w<=A;){const e=i(s,m[A+1]);o(e,p[w]),m[w++]=e}for(;j<=k;){const e=a[j++];null!==e&&n(e)}return this.ut=v,f(s,m),e}});export{c as repeat};\n//# sourceMappingURL=repeat.js.map\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nlet _RO;\nlet RO;\nexport default async function ResizeObserver() {\n    return RO || init();\n}\nasync function init() {\n    if (_RO) {\n        return (await _RO).default;\n    }\n    else {\n        _RO = window.ResizeObserver;\n        try {\n            new _RO(function () { });\n        }\n        catch (e) {\n            _RO = import('../polyfills/resize-observer-polyfill/ResizeObserver.js');\n            _RO = (await _RO).default;\n        }\n        return (RO = _RO);\n    }\n}\n//# sourceMappingURL=ResizeObserver.js.map","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport getResizeObserver from './polyfillLoaders/ResizeObserver.js';\nexport const virtualizerRef = Symbol('virtualizerRef');\nconst SIZER_ATTRIBUTE = 'virtualizer-sizer';\nexport class RangeChangedEvent extends Event {\n    constructor(range) {\n        super(RangeChangedEvent.eventName, { bubbles: true });\n        this.first = range.first;\n        this.last = range.last;\n    }\n}\nRangeChangedEvent.eventName = 'rangeChanged';\nexport class VisibilityChangedEvent extends Event {\n    constructor(range) {\n        super(VisibilityChangedEvent.eventName, { bubbles: true });\n        this.first = range.first;\n        this.last = range.last;\n    }\n}\nVisibilityChangedEvent.eventName = 'visibilityChanged';\n/**\n * Provides virtual scrolling boilerplate.\n *\n * Extensions of this class must set hostElement and layout.\n *\n * Extensions of this class must also override VirtualRepeater's DOM\n * manipulation methods.\n */\nexport class Virtualizer {\n    constructor(config) {\n        this._benchmarkStart = null;\n        /**\n         * Whether the layout should receive an updated viewport size on the next\n         * render.\n         */\n        // private _needsUpdateView: boolean = false;\n        this._layout = null;\n        this._clippingAncestors = [];\n        /**\n         * Layout provides these values, we set them on _render().\n         * TODO @straversi: Can we find an XOR type, usable for the key here?\n         */\n        this._scrollSize = null;\n        /**\n         * Difference between scroll target's current and required scroll offsets.\n         * Provided by layout.\n         */\n        this._scrollError = null;\n        /**\n         * A list of the positions (top, left) of the children in the current range.\n         */\n        this._childrenPos = null;\n        // TODO: (graynorton): type\n        this._childMeasurements = null;\n        this._toBeMeasured = new Map();\n        this._rangeChanged = true;\n        this._itemsChanged = true;\n        this._visibilityChanged = true;\n        this._isScroller = false;\n        this._sizer = null;\n        /**\n         * Resize observer attached to hostElement.\n         */\n        this._hostElementRO = null;\n        /**\n         * Resize observer attached to children.\n         */\n        this._childrenRO = null;\n        this._mutationObserver = null;\n        this._mutationPromise = null;\n        this._mutationPromiseResolver = null;\n        this._mutationsObserved = false;\n        this._scrollEventListeners = [];\n        this._scrollEventListenerOptions = {\n            passive: true,\n        };\n        // TODO (graynorton): Rethink, per longer comment below\n        this._loadListener = this._childLoaded.bind(this);\n        /**\n         * Index and position of item to scroll to.\n         */\n        this._scrollToIndex = null;\n        /**\n         * Items to render. Set by items.\n         */\n        this._items = [];\n        /**\n         * Index of the first child in the range, not necessarily the first visible child.\n         * TODO @straversi: Consider renaming these.\n         */\n        this._first = -1;\n        /**\n         * Index of the last child in the range.\n         */\n        this._last = -1;\n        /**\n         * Index of the first item intersecting the viewport.\n         */\n        this._firstVisible = -1;\n        /**\n         * Index of the last item intersecting the viewport.\n         */\n        this._lastVisible = -1;\n        this._scheduled = new WeakSet();\n        /**\n         * Invoked at the end of each render cycle: children in the range are\n         * measured, and their dimensions passed to this callback. Use it to layout\n         * children as needed.\n         */\n        this._measureCallback = null;\n        this._measureChildOverride = null;\n        if (!config) {\n            throw new Error('Virtualizer constructor requires a configuration object');\n        }\n        if (config.hostElement) {\n            this._init(config);\n        }\n        else {\n            throw new Error('Virtualizer configuration requires the \"hostElement\" property');\n        }\n    }\n    set items(items) {\n        if (Array.isArray(items) && items !== this._items) {\n            this._itemsChanged = true;\n            this._items = items;\n            this._schedule(this._updateLayout);\n        }\n    }\n    _init(config) {\n        this._isScroller = !!config.scroller;\n        this._initHostElement(config);\n        this._initLayout(config);\n    }\n    async _initObservers() {\n        this._mutationObserver = new MutationObserver(this._observeMutations.bind(this));\n        const ResizeObserver = await getResizeObserver();\n        this._hostElementRO = new ResizeObserver(() => this._hostElementSizeChanged());\n        this._childrenRO = new ResizeObserver(this._childrenSizeChanged.bind(this));\n    }\n    async _initLayout(config) {\n        if (config.layout) {\n            this.layout = config.layout;\n        }\n        else {\n            this.layout = (await import('./layouts/flow.js')).FlowLayout;\n        }\n    }\n    _initHostElement(config) {\n        const hostElement = (this._hostElement = config.hostElement);\n        this._applyVirtualizerStyles();\n        hostElement[virtualizerRef] = this;\n    }\n    async connected() {\n        await this._initObservers();\n        const includeSelf = this._isScroller;\n        this._clippingAncestors = getClippingAncestors(this._hostElement, includeSelf);\n        this._schedule(this._updateLayout);\n        this._observeAndListen();\n    }\n    _observeAndListen() {\n        this._mutationObserver.observe(this._hostElement, { childList: true });\n        this._mutationPromise = new Promise((resolve) => (this._mutationPromiseResolver = resolve));\n        this._hostElementRO.observe(this._hostElement);\n        this._scrollEventListeners.push(window);\n        window.addEventListener('scroll', this, this._scrollEventListenerOptions);\n        this._clippingAncestors.forEach((ancestor) => {\n            ancestor.addEventListener('scroll', this, this._scrollEventListenerOptions);\n            this._scrollEventListeners.push(ancestor);\n            this._hostElementRO.observe(ancestor);\n        });\n        this._children.forEach((child) => this._childrenRO.observe(child));\n        this._scrollEventListeners.forEach((target) => target.addEventListener('scroll', this, this._scrollEventListenerOptions));\n    }\n    disconnected() {\n        this._scrollEventListeners.forEach((target) => target.removeEventListener('scroll', this, this._scrollEventListenerOptions));\n        this._scrollEventListeners = [];\n        this._clippingAncestors = [];\n        this._mutationObserver.disconnect();\n        this._hostElementRO.disconnect();\n        this._childrenRO.disconnect();\n    }\n    _applyVirtualizerStyles() {\n        const hostElement = this._hostElement;\n        // Would rather set these CSS properties on the host using Shadow Root\n        // style scoping (and falling back to a global stylesheet where native\n        // Shadow DOM is not available), but this Mobile Safari bug is preventing\n        // that from working: https://bugs.webkit.org/show_bug.cgi?id=226195\n        const style = hostElement.style;\n        style.display = style.display || 'block';\n        style.position = style.position || 'relative';\n        style.contain = style.contain || 'strict';\n        if (this._isScroller) {\n            style.overflow = style.overflow || 'auto';\n            style.minHeight = style.minHeight || '150px';\n        }\n    }\n    _getSizer() {\n        const hostElement = this._hostElement;\n        if (!this._sizer) {\n            // Use a pre-existing sizer element if provided (for better integration\n            // with vDOM renderers)\n            let sizer = hostElement.querySelector(`[${SIZER_ATTRIBUTE}]`);\n            if (!sizer) {\n                sizer = document.createElement('div');\n                sizer.setAttribute(SIZER_ATTRIBUTE, '');\n                hostElement.appendChild(sizer);\n            }\n            // When the scrollHeight is large, the height of this element might be\n            // ignored. Setting content and font-size ensures the element has a size.\n            Object.assign(sizer.style, {\n                position: 'absolute',\n                margin: '-2px 0 0 0',\n                padding: 0,\n                visibility: 'hidden',\n                fontSize: '2px',\n            });\n            sizer.innerHTML = '&nbsp;';\n            sizer.setAttribute(SIZER_ATTRIBUTE, '');\n            this._sizer = sizer;\n        }\n        return this._sizer;\n    }\n    // This will always actually return a layout instance,\n    // but TypeScript wants the getter and setter types to be the same\n    get layout() {\n        return this._layout;\n    }\n    // TODO (graynorton): Consider not allowing dynamic layout changes and\n    // instead just creating a new Virtualizer instance when a layout\n    // change is desired. Might simplify quite a bit.\n    set layout(layout) {\n        if (this._layout === layout) {\n            return;\n        }\n        let _layout = null;\n        let _config = {};\n        if (typeof layout === 'object') {\n            if (layout.type !== undefined) {\n                _layout = layout.type;\n                // delete (layout as LayoutSpecifier).type;\n            }\n            _config = layout;\n        }\n        else {\n            _layout = layout;\n        }\n        if (typeof _layout === 'function') {\n            if (this._layout instanceof _layout) {\n                if (_config) {\n                    this._layout.config = _config;\n                }\n                return;\n            }\n            else {\n                _layout = new _layout(_config);\n            }\n        }\n        if (this._layout) {\n            this._measureCallback = null;\n            this._measureChildOverride = null;\n            this._layout.removeEventListener('scrollsizechange', this);\n            this._layout.removeEventListener('scrollerrorchange', this);\n            this._layout.removeEventListener('itempositionchange', this);\n            this._layout.removeEventListener('rangechange', this);\n            this._sizeHostElement(undefined);\n            this._hostElement.removeEventListener('load', this._loadListener, true);\n        }\n        this._layout = _layout;\n        if (this._layout) {\n            if (this._layout.measureChildren &&\n                typeof this._layout.updateItemSizes === 'function') {\n                if (typeof this._layout.measureChildren === 'function') {\n                    this._measureChildOverride = this._layout.measureChildren;\n                }\n                this._measureCallback = this._layout.updateItemSizes.bind(this._layout);\n            }\n            this._layout.addEventListener('scrollsizechange', this);\n            this._layout.addEventListener('scrollerrorchange', this);\n            this._layout.addEventListener('itempositionchange', this);\n            this._layout.addEventListener('rangechange', this);\n            if (this._layout.listenForChildLoadEvents) {\n                this._hostElement.addEventListener('load', this._loadListener, true);\n            }\n            this._schedule(this._updateLayout);\n        }\n    }\n    // TODO (graynorton): Rework benchmarking so that it has no API and\n    // instead is always on except in production builds\n    startBenchmarking() {\n        if (this._benchmarkStart === null) {\n            this._benchmarkStart = window.performance.now();\n        }\n    }\n    stopBenchmarking() {\n        if (this._benchmarkStart !== null) {\n            const now = window.performance.now();\n            const timeElapsed = now - this._benchmarkStart;\n            const entries = performance.getEntriesByName('uv-virtualizing', 'measure');\n            const virtualizationTime = entries\n                .filter((e) => e.startTime >= this._benchmarkStart && e.startTime < now)\n                .reduce((t, m) => t + m.duration, 0);\n            this._benchmarkStart = null;\n            return { timeElapsed, virtualizationTime };\n        }\n        return null;\n    }\n    _measureChildren() {\n        const mm = {};\n        const children = this._children;\n        const fn = this._measureChildOverride || this._measureChild;\n        for (let i = 0; i < children.length; i++) {\n            const child = children[i];\n            const idx = this._first + i;\n            if (this._itemsChanged || this._toBeMeasured.has(child)) {\n                mm[idx] = fn.call(this, child, this._items[idx] /*as unknown as object*/);\n            }\n        }\n        this._childMeasurements = mm;\n        this._schedule(this._updateLayout);\n        this._toBeMeasured.clear();\n    }\n    /**\n     * Returns the width, height, and margins of the given child.\n     */\n    _measureChild(element) {\n        // offsetWidth doesn't take transforms in consideration, so we use\n        // getBoundingClientRect which does.\n        const { width, height } = element.getBoundingClientRect();\n        return Object.assign({ width, height }, getMargins(element));\n    }\n    /**\n     * Index and position of item to scroll to. The virtualizer will fix to that point\n     * until the user scrolls.\n     */\n    set scrollToIndex(newValue) {\n        this._scrollToIndex = newValue;\n        this._schedule(this._updateLayout);\n    }\n    async _schedule(method) {\n        if (!this._scheduled.has(method)) {\n            this._scheduled.add(method);\n            await Promise.resolve();\n            this._scheduled.delete(method);\n            method.call(this);\n        }\n    }\n    async _updateDOM() {\n        const { _rangeChanged, _itemsChanged } = this;\n        if (this._visibilityChanged) {\n            this._notifyVisibility();\n            this._visibilityChanged = false;\n        }\n        if (_rangeChanged || _itemsChanged) {\n            this._notifyRange();\n            await this._mutationPromise;\n        }\n        this._children.forEach((child) => this._childrenRO.observe(child));\n        this._positionChildren(this._childrenPos);\n        this._sizeHostElement(this._scrollSize);\n        if (this._scrollError) {\n            this._correctScrollError(this._scrollError);\n            this._scrollError = null;\n        }\n        if (this._benchmarkStart && 'mark' in window.performance) {\n            window.performance.mark('uv-end');\n        }\n    }\n    _updateLayout() {\n        if (this._layout) {\n            this._layout.totalItems = this._items.length;\n            if (this._scrollToIndex !== null) {\n                this._layout.scrollToIndex(this._scrollToIndex.index, this._scrollToIndex.position);\n                this._scrollToIndex = null;\n            }\n            this._updateView();\n            if (this._childMeasurements !== null) {\n                // If the layout has been changed, we may have measurements but no callback\n                if (this._measureCallback) {\n                    this._measureCallback(this._childMeasurements);\n                }\n                this._childMeasurements = null;\n            }\n            this._layout.reflowIfNeeded(this._itemsChanged);\n            if (this._benchmarkStart && 'mark' in window.performance) {\n                window.performance.mark('uv-end');\n            }\n        }\n    }\n    _handleScrollEvent() {\n        if (this._benchmarkStart && 'mark' in window.performance) {\n            try {\n                window.performance.measure('uv-virtualizing', 'uv-start', 'uv-end');\n            }\n            catch (e) {\n                console.warn('Error measuring performance data: ', e);\n            }\n            window.performance.mark('uv-start');\n        }\n        this._schedule(this._updateLayout);\n    }\n    handleEvent(event) {\n        switch (event.type) {\n            case 'scroll':\n                if (event.currentTarget === window ||\n                    this._clippingAncestors.includes(event.currentTarget)) {\n                    this._handleScrollEvent();\n                }\n                break;\n            case 'scrollsizechange':\n                this._scrollSize = event.detail;\n                this._schedule(this._updateDOM);\n                break;\n            case 'scrollerrorchange':\n                this._scrollError = event.detail;\n                this._schedule(this._updateDOM);\n                break;\n            case 'itempositionchange':\n                this._childrenPos = event.detail;\n                this._schedule(this._updateDOM);\n                break;\n            case 'rangechange':\n                this._adjustRange(event.detail);\n                this._schedule(this._updateDOM);\n                break;\n            default:\n                console.warn('event not handled', event);\n        }\n    }\n    get _children() {\n        const arr = [];\n        let next = this._hostElement.firstElementChild;\n        while (next) {\n            if (!next.hasAttribute(SIZER_ATTRIBUTE)) {\n                arr.push(next);\n            }\n            next = next.nextElementSibling;\n        }\n        return arr;\n    }\n    _updateView() {\n        const hostElement = this._hostElement;\n        const layout = this._layout;\n        let top, left, bottom, right;\n        const hostElementBounds = hostElement.getBoundingClientRect();\n        top = 0;\n        left = 0;\n        bottom = window.innerHeight;\n        right = window.innerWidth;\n        for (const ancestor of this._clippingAncestors) {\n            const ancestorBounds = ancestor.getBoundingClientRect();\n            top = Math.max(top, ancestorBounds.top);\n            left = Math.max(left, ancestorBounds.left);\n            bottom = Math.min(bottom, ancestorBounds.bottom);\n            right = Math.min(right, ancestorBounds.right);\n        }\n        const scrollTop = top - hostElementBounds.top + hostElement.scrollTop;\n        const scrollLeft = left - hostElementBounds.left + hostElement.scrollLeft;\n        const height = Math.max(1, bottom - top);\n        const width = Math.max(1, right - left);\n        layout.viewportSize = { width, height };\n        layout.viewportScroll = { top: scrollTop, left: scrollLeft };\n    }\n    /**\n     * Styles the host element so that its size reflects the\n     * total size of all items.\n     */\n    _sizeHostElement(size) {\n        // Some browsers seem to crap out if the host element gets larger than\n        // a certain size, so we clamp it here (this value based on ad hoc\n        // testing in Chrome / Safari / Firefox Mac)\n        const max = 8200000;\n        const h = size && size.width !== null ? Math.min(max, size.width) : 0;\n        const v = size && size.height !== null ? Math.min(max, size.height) : 0;\n        if (this._isScroller) {\n            this._getSizer().style.transform = `translate(${h}px, ${v}px)`;\n        }\n        else {\n            const style = this._hostElement.style;\n            style.minWidth = h ? `${h}px` : '100%';\n            style.minHeight = v ? `${v}px` : '100%';\n        }\n    }\n    /**\n     * Sets the top and left transform style of the children from the values in\n     * pos.\n     */\n    _positionChildren(pos) {\n        if (pos) {\n            const children = this._children;\n            Object.keys(pos).forEach((key) => {\n                const idx = key - this._first;\n                const child = children[idx];\n                if (child) {\n                    const { top, left, width, height, xOffset, yOffset } = pos[key];\n                    child.style.position = 'absolute';\n                    child.style.boxSizing = 'border-box';\n                    child.style.transform = `translate(${left}px, ${top}px)`;\n                    if (width !== undefined) {\n                        child.style.width = width + 'px';\n                    }\n                    if (height !== undefined) {\n                        child.style.height = height + 'px';\n                    }\n                    child.style.left =\n                        xOffset === undefined ? null : xOffset + 'px';\n                    child.style.top =\n                        yOffset === undefined ? null : yOffset + 'px';\n                }\n            });\n        }\n    }\n    async _adjustRange(range) {\n        const { _first, _last, _firstVisible, _lastVisible } = this;\n        this._first = range.first;\n        this._last = range.last;\n        this._firstVisible = range.firstVisible;\n        this._lastVisible = range.lastVisible;\n        this._rangeChanged =\n            this._rangeChanged || this._first !== _first || this._last !== _last;\n        this._visibilityChanged =\n            this._visibilityChanged ||\n                this._firstVisible !== _firstVisible ||\n                this._lastVisible !== _lastVisible;\n    }\n    _correctScrollError(err) {\n        const target = this._clippingAncestors[0];\n        if (target) {\n            target.scrollTop -= err.top;\n            target.scrollLeft -= err.left;\n        }\n        else {\n            window.scroll(window.pageXOffset - err.left, window.pageYOffset - err.top);\n        }\n    }\n    /**\n     * Emits a rangechange event with the current first, last, firstVisible, and\n     * lastVisible.\n     */\n    _notifyRange() {\n        this._hostElement.dispatchEvent(new RangeChangedEvent({ first: this._first, last: this._last }));\n    }\n    _notifyVisibility() {\n        this._hostElement.dispatchEvent(new VisibilityChangedEvent({\n            first: this._firstVisible,\n            last: this._lastVisible,\n        }));\n    }\n    /**\n     * Render and update the view at the next opportunity with the given\n     * hostElement size.\n     */\n    _hostElementSizeChanged() {\n        this._schedule(this._updateLayout);\n    }\n    async _observeMutations() {\n        if (!this._mutationsObserved) {\n            this._mutationsObserved = true;\n            this._mutationPromiseResolver();\n            this._mutationPromise = new Promise((resolve) => (this._mutationPromiseResolver = resolve));\n            this._mutationsObserved = false;\n        }\n    }\n    // TODO (graynorton): Rethink how this works. Probably child loading is too specific\n    // to have dedicated support for; might want some more generic lifecycle hooks for\n    // layouts to use. Possibly handle measurement this way, too, or maybe that remains\n    // a first-class feature?\n    _childLoaded() { }\n    // This is the callback for the ResizeObserver that watches the\n    // virtualizer's children. We land here at the end of every virtualizer\n    // update cycle that results in changes to physical items, and we also\n    // end up here if one or more children change size independently of\n    // the virtualizer update cycle.\n    _childrenSizeChanged(changes) {\n        // Only measure if the layout requires it\n        if (this._layout.measureChildren) {\n            for (const change of changes) {\n                this._toBeMeasured.set(change.target, change.contentRect);\n            }\n            this._measureChildren();\n        }\n        // If this is the end of an update cycle, we need to reset some\n        // internal state. This should be a harmless no-op if we're handling\n        // an out-of-cycle ResizeObserver callback, so we don't need to\n        // distinguish between the two cases.\n        this._itemsChanged = false;\n        this._rangeChanged = false;\n    }\n}\nfunction getMargins(el) {\n    const style = window.getComputedStyle(el);\n    return {\n        marginTop: getMarginValue(style.marginTop),\n        marginRight: getMarginValue(style.marginRight),\n        marginBottom: getMarginValue(style.marginBottom),\n        marginLeft: getMarginValue(style.marginLeft),\n    };\n}\nfunction getMarginValue(value) {\n    const float = value ? parseFloat(value) : NaN;\n    return Number.isNaN(float) ? 0 : float;\n}\n// TODO (graynorton): Deal with iframes?\nfunction getParentElement(el) {\n    if (el.parentElement !== null) {\n        return el.parentElement;\n    }\n    const parentNode = el.parentNode;\n    if (parentNode && parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n        return parentNode.host || null;\n    }\n    return null;\n}\nfunction getElementAncestors(el, includeSelf = false) {\n    const ancestors = [];\n    let parent = includeSelf ? el : getParentElement(el);\n    while (parent !== null) {\n        ancestors.push(parent);\n        parent = getParentElement(parent);\n    }\n    return ancestors;\n}\nfunction getClippingAncestors(el, includeSelf = false) {\n    return getElementAncestors(el, includeSelf).filter((a) => getComputedStyle(a).overflow !== 'visible');\n}\n//# sourceMappingURL=Virtualizer.js.map"],"names":["generateMap","list","start","end","i","map","set","repeat","directive","constructor","partInfo","super","type","PartType","CHILD","_getValuesAndKeys","items","keyFnOrTemplate","template","keyFn","values","keys","index","item","render","update","containerPart","getCommittedValue","newValues","newKeys","this","Array","isArray","oldParts","_itemKeys","newParts","oldKeyToIndexMap","oldHead","oldTail","length","newHead","newTail","oldKeys","setChildPartValue","insertPart","newKeyToIndexMap","has","get","oldPart","oldIndex","newPart","removePart","setCommittedValue","noChange","async","_RO","default","window","ResizeObserver","e","import","init","virtualizerRef","Symbol","range","RangeChangedEvent","eventName","bubbles","first","last","VisibilityChangedEvent","config","passive","_childLoaded","bind","hostElement","_init","_items","_itemsChanged","_schedule","_updateLayout","_isScroller","scroller","_initHostElement","_initLayout","_mutationObserver","_observeMutations","_hostElementRO","_hostElementSizeChanged","_childrenRO","_childrenSizeChanged","layout","FlowLayout","_hostElement","_applyVirtualizerStyles","_initObservers","_clippingAncestors","el","includeSelf","getParentElement","parent","ancestors","push","filter","a","getComputedStyle","overflow","getClippingAncestors","_observeAndListen","observe","childList","_mutationPromise","resolve","_mutationPromiseResolver","_scrollEventListeners","addEventListener","_scrollEventListenerOptions","forEach","ancestor","_children","child","target","disconnected","removeEventListener","disconnect","style","display","position","contain","minHeight","_getSizer","_sizer","querySelector","sizer","document","createElement","setAttribute","appendChild","Object","assign","margin","padding","visibility","fontSize","innerHTML","_layout","undefined","_config","_measureCallback","_measureChildOverride","_sizeHostElement","_loadListener","measureChildren","updateItemSizes","listenForChildLoadEvents","startBenchmarking","_benchmarkStart","performance","now","stopBenchmarking","getEntriesByName","startTime","reduce","t","m","duration","timeElapsed","virtualizationTime","_measureChildren","_measureChild","children","_first","_toBeMeasured","mm","idx","fn","call","_childMeasurements","clear","element","width","height","getBoundingClientRect","marginTop","getMarginValue","marginRight","marginBottom","marginLeft","getMargins","newValue","_scrollToIndex","method","_scheduled","add","delete","_rangeChanged","_visibilityChanged","_notifyVisibility","_notifyRange","_positionChildren","_childrenPos","_scrollSize","_scrollError","_correctScrollError","mark","totalItems","scrollToIndex","_updateView","reflowIfNeeded","_handleScrollEvent","measure","console","warn","handleEvent","event","currentTarget","includes","detail","_updateDOM","_adjustRange","firstElementChild","next","hasAttribute","arr","nextElementSibling","left","bottom","right","top","innerHeight","innerWidth","Math","max","ancestorBounds","min","hostElementBounds","scrollTop","scrollLeft","viewportSize","viewportScroll","size","transform","h","v","minWidth","pos","key","xOffset","yOffset","boxSizing","_last","_firstVisible","_lastVisible","firstVisible","lastVisible","err","scroll","pageXOffset","pageYOffset","dispatchEvent","_mutationsObserved","changes","change","contentRect","value","parseFloat","NaN","isNaN","float","parentElement","parentNode","nodeType","Node","DOCUMENT_FRAGMENT_NODE","host"],"mappings":"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"}
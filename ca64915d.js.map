{"version":3,"file":"ca64915d.js","sources":["../../../node_modules/@lit-labs/virtualizer/polyfillLoaders/EventTarget.js","../../../node_modules/@lit-labs/virtualizer/layouts/shared/BaseLayout.js"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nlet _ET;\nlet ET;\nexport default async function EventTarget() {\n    return ET || init();\n}\nasync function init() {\n    _ET = window.EventTarget;\n    try {\n        new _ET();\n    }\n    catch {\n        _ET = (await import('event-target-shim')).EventTarget;\n    }\n    return (ET = _ET);\n}\n//# sourceMappingURL=EventTarget.js.map","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport EventTarget from '../../polyfillLoaders/EventTarget.js';\nexport function dim1(direction) {\n    return direction === 'horizontal' ? 'width' : 'height';\n}\nexport function dim2(direction) {\n    return direction === 'horizontal' ? 'height' : 'width';\n}\nexport function pos1(direction) {\n    return direction === 'horizontal' ? 'left' : 'top';\n}\nexport function pos2(direction) {\n    return direction === 'horizontal' ? 'top' : 'left';\n}\nexport class BaseLayout {\n    constructor(config) {\n        /**\n         * The last set viewport scroll position.\n         */\n        this._latestCoords = { left: 0, top: 0 };\n        /**\n         * Scrolling direction.\n         */\n        this._direction = null;\n        /**\n         * Dimensions of the viewport.\n         */\n        this._viewportSize = { width: 0, height: 0 };\n        this.totalScrollSize = { width: 0, height: 0 };\n        this.offsetWithinScroller = { left: 0, top: 0 };\n        /**\n         * Flag for debouncing asynchnronous reflow requests.\n         */\n        this._pendingReflow = false;\n        this._pendingLayoutUpdate = false;\n        this._pin = null;\n        /**\n         * The index of the first item intersecting the viewport.\n         */\n        this._firstVisible = 0;\n        /**\n         * The index of the last item intersecting the viewport.\n         */\n        this._lastVisible = 0;\n        this._eventTargetPromise = EventTarget().then((Ctor) => {\n            this._eventTarget = new Ctor();\n        });\n        /**\n         * Pixel offset in the scroll direction of the first child.\n         */\n        this._physicalMin = 0;\n        /**\n         * Pixel offset in the scroll direction of the last child.\n         */\n        this._physicalMax = 0;\n        /**\n         * Index of the first child.\n         */\n        this._first = -1;\n        /**\n         * Index of the last child.\n         */\n        this._last = -1;\n        /**\n         * Length in the scrolling direction.\n         */\n        this._sizeDim = 'height';\n        /**\n         * Length in the non-scrolling direction.\n         */\n        this._secondarySizeDim = 'width';\n        /**\n         * Position in the scrolling direction.\n         */\n        this._positionDim = 'top';\n        /**\n         * Position in the non-scrolling direction.\n         */\n        this._secondaryPositionDim = 'left';\n        /**\n         * Current scroll offset in pixels.\n         */\n        this._scrollPosition = 0;\n        /**\n         * Difference between current scroll offset and scroll offset calculated due\n         * to a reflow.\n         */\n        this._scrollError = 0;\n        /**\n         * Total number of items that could possibly be displayed. Used to help\n         * calculate the scroll size.\n         */\n        this._items = [];\n        /**\n         * The total (estimated) length of all items in the scrolling direction.\n         */\n        this._scrollSize = 1;\n        /**\n         * Number of pixels beyond the viewport to still include\n         * in the active range of items.\n         */\n        // TODO (graynorton): Probably want to make this something we calculate based\n        // on viewport size, item size, other factors, possibly still with a dial of some kind\n        this._overhang = 1000;\n        this._eventTarget = null;\n        // Delay setting config so that subclasses do setup work first\n        Promise.resolve().then(() => (this.config = config || this._defaultConfig));\n    }\n    get _defaultConfig() {\n        return {\n            direction: 'vertical',\n        };\n    }\n    set config(config) {\n        Object.assign(this, Object.assign({}, this._defaultConfig, config));\n    }\n    get config() {\n        return {\n            direction: this.direction,\n        };\n    }\n    /**\n     * Maximum index of children + 1, to help estimate total height of the scroll\n     * space.\n     */\n    get items() {\n        return this._items;\n    }\n    set items(items) {\n        if (items !== this._items) {\n            this._items = items;\n            this._scheduleReflow();\n        }\n    }\n    /**\n     * Primary scrolling direction.\n     */\n    get direction() {\n        return this._direction;\n    }\n    set direction(dir) {\n        // Force it to be either horizontal or vertical.\n        dir = dir === 'horizontal' ? dir : 'vertical';\n        if (dir !== this._direction) {\n            this._direction = dir;\n            this._sizeDim = dir === 'horizontal' ? 'width' : 'height';\n            this._secondarySizeDim = dir === 'horizontal' ? 'height' : 'width';\n            this._positionDim = dir === 'horizontal' ? 'left' : 'top';\n            this._secondaryPositionDim = dir === 'horizontal' ? 'top' : 'left';\n            this._triggerReflow();\n        }\n    }\n    /**\n     * Height and width of the viewport.\n     */\n    get viewportSize() {\n        return this._viewportSize;\n    }\n    set viewportSize(dims) {\n        const { _viewDim1, _viewDim2 } = this;\n        Object.assign(this._viewportSize, dims);\n        if (_viewDim2 !== this._viewDim2) {\n            // this._viewDim2Changed();\n            this._scheduleLayoutUpdate();\n        }\n        else if (_viewDim1 !== this._viewDim1) {\n            this._checkThresholds();\n        }\n    }\n    /**\n     * Scroll offset of the viewport.\n     */\n    get viewportScroll() {\n        return this._latestCoords;\n    }\n    set viewportScroll(coords) {\n        Object.assign(this._latestCoords, coords);\n        const oldPos = this._scrollPosition;\n        this._scrollPosition = this._latestCoords[this._positionDim];\n        const change = Math.abs(oldPos - this._scrollPosition);\n        if (change >= 1) {\n            this._updateVisibleIndices({ emit: true });\n        }\n        this._checkThresholds();\n    }\n    /**\n     * Perform a reflow if one has been scheduled.\n     */\n    reflowIfNeeded(force = false) {\n        if (force || this._pendingReflow) {\n            this._pendingReflow = false;\n            this._reflow();\n        }\n    }\n    set pin(options) {\n        this._pin = options;\n        this._triggerReflow();\n    }\n    get pin() {\n        if (this._pin !== null) {\n            const { index, block } = this._pin;\n            return {\n                index: Math.max(0, Math.min(index, this.items.length - 1)),\n                block,\n            };\n        }\n        return null;\n    }\n    _clampScrollPosition(val) {\n        return Math.max(-this.offsetWithinScroller[this._positionDim], Math.min(val, this.totalScrollSize[dim1(this.direction)] - this._viewDim1));\n    }\n    unpin() {\n        if (this._pin !== null) {\n            this._emitUnpinned();\n            this._pin = null;\n        }\n    }\n    async dispatchEvent(evt) {\n        await this._eventTargetPromise;\n        this._eventTarget.dispatchEvent(evt);\n    }\n    async addEventListener(type, listener, options) {\n        await this._eventTargetPromise;\n        this._eventTarget.addEventListener(type, listener, options);\n    }\n    async removeEventListener(type, callback, options) {\n        await this._eventTargetPromise;\n        this._eventTarget.removeEventListener(type, callback, options);\n    }\n    _updateLayout() {\n        // Override\n    }\n    // protected _viewDim2Changed(): void {\n    //   this._scheduleLayoutUpdate();\n    // }\n    /**\n     * The height or width of the viewport, whichever corresponds to the scrolling direction.\n     */\n    get _viewDim1() {\n        return this._viewportSize[this._sizeDim];\n    }\n    /**\n     * The height or width of the viewport, whichever does NOT correspond to the scrolling direction.\n     */\n    get _viewDim2() {\n        return this._viewportSize[this._secondarySizeDim];\n    }\n    _scheduleReflow() {\n        this._pendingReflow = true;\n    }\n    _scheduleLayoutUpdate() {\n        this._pendingLayoutUpdate = true;\n        this._scheduleReflow();\n    }\n    // For triggering a reflow based on incoming changes to\n    // the layout config.\n    _triggerReflow() {\n        this._scheduleLayoutUpdate();\n        // TODO graynorton@: reflowIfNeeded() isn't really supposed\n        // to be called internally. Address in larger cleanup\n        // of virtualizer / layout interaction pattern.\n        // this.reflowIfNeeded(true);\n        Promise.resolve().then(() => this.reflowIfNeeded());\n    }\n    _reflow() {\n        if (this._pendingLayoutUpdate) {\n            this._updateLayout();\n            this._pendingLayoutUpdate = false;\n        }\n        this._updateScrollSize();\n        this._setPositionFromPin();\n        this._getActiveItems();\n        this._updateVisibleIndices();\n        this._emitScrollSize();\n        this._emitRange();\n        this._emitChildPositions();\n        this._emitScrollError();\n    }\n    /**\n     * If we are supposed to be pinned to a particular\n     * item or set of coordinates, we set `_scrollPosition`\n     * accordingly and adjust `_scrollError` as needed\n     * so that the virtualizer can keep the scroll\n     * position in the DOM in sync\n     */\n    _setPositionFromPin() {\n        if (this.pin !== null) {\n            const lastScrollPosition = this._scrollPosition;\n            const { index, block } = this.pin;\n            this._scrollPosition =\n                this._calculateScrollIntoViewPosition({\n                    index,\n                    block: block || 'start',\n                }) - this.offsetWithinScroller[this._positionDim];\n            this._scrollError = lastScrollPosition - this._scrollPosition;\n        }\n    }\n    /**\n     * Calculate the coordinates to scroll to, given\n     * a request to scroll to the element at a specific\n     * index.\n     *\n     * Supports the same positioning options (`start`,\n     * `center`, `end`, `nearest`) as the standard\n     * `Element.scrollIntoView()` method, but currently\n     * only considers the provided value in the `block`\n     * dimension, since we don't yet have any layouts\n     * that support virtualization in two dimensions.\n     */\n    _calculateScrollIntoViewPosition(options) {\n        const { block } = options;\n        const index = Math.min(this.items.length, Math.max(0, options.index));\n        const itemStartPosition = this._getItemPosition(index)[this._positionDim];\n        let scrollPosition = itemStartPosition;\n        if (block !== 'start') {\n            const itemSize = this._getItemSize(index)[this._sizeDim];\n            if (block === 'center') {\n                scrollPosition =\n                    itemStartPosition - 0.5 * this._viewDim1 + 0.5 * itemSize;\n            }\n            else {\n                const itemEndPosition = itemStartPosition - this._viewDim1 + itemSize;\n                if (block === 'end') {\n                    scrollPosition = itemEndPosition;\n                }\n                else {\n                    // block === 'nearest'\n                    const currentScrollPosition = this._scrollPosition;\n                    scrollPosition =\n                        Math.abs(currentScrollPosition - itemStartPosition) <\n                            Math.abs(currentScrollPosition - itemEndPosition)\n                            ? itemStartPosition\n                            : itemEndPosition;\n                }\n            }\n        }\n        scrollPosition += this.offsetWithinScroller[this._positionDim];\n        return this._clampScrollPosition(scrollPosition);\n    }\n    getScrollIntoViewCoordinates(options) {\n        return {\n            [this._positionDim]: this._calculateScrollIntoViewPosition(options),\n        };\n    }\n    _emitUnpinned() {\n        this.dispatchEvent(new CustomEvent('unpinned'));\n    }\n    _emitRange() {\n        const detail = {\n            first: this._first,\n            last: this._last,\n            firstVisible: this._firstVisible,\n            lastVisible: this._lastVisible,\n        };\n        this.dispatchEvent(new CustomEvent('rangechange', { detail }));\n    }\n    _emitScrollSize() {\n        const detail = {\n            [this._sizeDim]: this._scrollSize,\n            [this._secondarySizeDim]: null,\n        };\n        this.dispatchEvent(new CustomEvent('scrollsizechange', { detail }));\n    }\n    _emitScrollError() {\n        if (this._scrollError) {\n            const detail = {\n                [this._positionDim]: this._scrollError,\n                [this._secondaryPositionDim]: 0,\n            };\n            this.dispatchEvent(new CustomEvent('scrollerrorchange', { detail }));\n            this._scrollError = 0;\n        }\n    }\n    /**\n     * Get or estimate the top and left positions of items in the current range.\n     * Emit an itempositionchange event with these positions.\n     */\n    _emitChildPositions() {\n        if (this._first !== -1 && this._last !== -1) {\n            const detail = new Map();\n            for (let idx = this._first; idx <= this._last; idx++) {\n                detail.set(idx, this._getItemPosition(idx));\n            }\n            this.dispatchEvent(new CustomEvent('itempositionchange', { detail }));\n        }\n    }\n    /**\n     * Number of items to display.\n     */\n    get _num() {\n        if (this._first === -1 || this._last === -1) {\n            return 0;\n        }\n        return this._last - this._first + 1;\n    }\n    _checkThresholds() {\n        if ((this._viewDim1 === 0 && this._num > 0) || this._pin !== null) {\n            this._scheduleReflow();\n        }\n        else {\n            const min = Math.max(0, this._scrollPosition - this._overhang);\n            const max = Math.min(this._scrollSize, this._scrollPosition + this._viewDim1 + this._overhang);\n            if (this._physicalMin > min || this._physicalMax < max) {\n                this._scheduleReflow();\n            }\n        }\n    }\n    /**\n     * Find the indices of the first and last items to intersect the viewport.\n     * Emit a visibleindiceschange event when either index changes.\n     */\n    _updateVisibleIndices(options) {\n        if (this._first === -1 || this._last === -1)\n            return;\n        let firstVisible = this._first;\n        while (firstVisible < this._last &&\n            Math.round(this._getItemPosition(firstVisible)[this._positionDim] +\n                this._getItemSize(firstVisible)[this._sizeDim]) <= Math.round(this._scrollPosition)) {\n            firstVisible++;\n        }\n        let lastVisible = this._last;\n        while (lastVisible > this._first &&\n            Math.round(this._getItemPosition(lastVisible)[this._positionDim]) >=\n                Math.round(this._scrollPosition + this._viewDim1)) {\n            lastVisible--;\n        }\n        if (firstVisible !== this._firstVisible ||\n            lastVisible !== this._lastVisible) {\n            this._firstVisible = firstVisible;\n            this._lastVisible = lastVisible;\n            if (options && options.emit) {\n                this._emitRange();\n            }\n        }\n    }\n}\n//# sourceMappingURL=BaseLayout.js.map"],"names":["_ET","ET","async","EventTarget","window","import","init","dim1","direction","dim2","BaseLayout","constructor","config","this","_latestCoords","left","top","_direction","_viewportSize","width","height","totalScrollSize","_pendingReflow","_pendingLayoutUpdate","_pin","_firstVisible","_lastVisible","_eventTargetPromise","then","Ctor","_eventTarget","_physicalMin","_physicalMax","_first","_last","_sizeDim","_secondarySizeDim","_positionDim","_secondaryPositionDim","_scrollPosition","_scrollError","_items","_scrollSize","_overhang","Promise","resolve","_defaultConfig","Object","assign","items","_scheduleReflow","dir","_triggerReflow","viewportSize","dims","_viewDim1","_viewDim2","_scheduleLayoutUpdate","_checkThresholds","viewportScroll","coords","oldPos","Math","abs","_updateVisibleIndices","emit","reflowIfNeeded","force","_reflow","pin","options","index","block","max","min","length","_clampScrollPosition","val","offsetWithinScroller","unpin","_emitUnpinned","evt","dispatchEvent","type","listener","addEventListener","callback","removeEventListener","_updateLayout","_updateScrollSize","_setPositionFromPin","_getActiveItems","_emitScrollSize","_emitRange","_emitChildPositions","_emitScrollError","lastScrollPosition","_calculateScrollIntoViewPosition","itemStartPosition","_getItemPosition","scrollPosition","itemSize","_getItemSize","itemEndPosition","currentScrollPosition","getScrollIntoViewCoordinates","detail","first","last","firstVisible","lastVisible","CustomEvent","Map","idx","set","_num","round"],"mappings":"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","x_google_ignoreList":[0,1]}
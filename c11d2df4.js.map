{"version":3,"file":"c11d2df4.js","sources":["../../../node_modules/@lit-labs/virtualizer/layouts/shared/SizeCache.js","../../../node_modules/@lit-labs/virtualizer/polyfillLoaders/EventTarget.js","../../../node_modules/@lit-labs/virtualizer/layouts/flow.js","../../../node_modules/@lit-labs/virtualizer/layouts/shared/BaseLayout.js"],"sourcesContent":["export class SizeCache {\n    constructor(config) {\n        this._map = new Map();\n        this._roundAverageSize = true;\n        this.totalSize = 0;\n        if ((config === null || config === void 0 ? void 0 : config.roundAverageSize) === false) {\n            this._roundAverageSize = false;\n        }\n    }\n    set(index, value) {\n        const prev = this._map.get(index) || 0;\n        this._map.set(index, value);\n        this.totalSize += value - prev;\n    }\n    get averageSize() {\n        if (this._map.size > 0) {\n            const average = this.totalSize / this._map.size;\n            return this._roundAverageSize ? Math.round(average) : average;\n        }\n        return 0;\n    }\n    getSize(index) {\n        return this._map.get(index);\n    }\n    clear() {\n        this._map.clear();\n        this.totalSize = 0;\n    }\n}\n//# sourceMappingURL=SizeCache.js.map","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nlet _ET;\nlet ET;\nexport default async function EventTarget() {\n    return ET || init();\n}\nasync function init() {\n    _ET = window.EventTarget;\n    try {\n        new _ET();\n    }\n    catch {\n        _ET = (await import('event-target-shim')).EventTarget;\n    }\n    return (ET = _ET);\n}\n//# sourceMappingURL=EventTarget.js.map","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { SizeCache } from './shared/SizeCache.js';\nimport { BaseLayout, dim1 } from './shared/BaseLayout.js';\nexport const flow = (config) => Object.assign({\n    type: FlowLayout,\n}, config);\nfunction leadingMargin(direction) {\n    return direction === 'horizontal' ? 'marginLeft' : 'marginTop';\n}\nfunction trailingMargin(direction) {\n    return direction === 'horizontal' ? 'marginRight' : 'marginBottom';\n}\nfunction offset(direction) {\n    return direction === 'horizontal' ? 'xOffset' : 'yOffset';\n}\nfunction collapseMargins(a, b) {\n    const m = [a, b].sort();\n    return m[1] <= 0 ? Math.min(...m) : m[0] >= 0 ? Math.max(...m) : m[0] + m[1];\n}\nclass MetricsCache {\n    constructor() {\n        this._childSizeCache = new SizeCache();\n        this._marginSizeCache = new SizeCache();\n        this._metricsCache = new Map();\n    }\n    update(metrics, direction) {\n        var _a, _b;\n        const marginsToUpdate = new Set();\n        Object.keys(metrics).forEach((key) => {\n            const k = Number(key);\n            this._metricsCache.set(k, metrics[k]);\n            this._childSizeCache.set(k, metrics[k][dim1(direction)]);\n            marginsToUpdate.add(k);\n            marginsToUpdate.add(k + 1);\n        });\n        for (const k of marginsToUpdate) {\n            const a = ((_a = this._metricsCache.get(k)) === null || _a === void 0 ? void 0 : _a[leadingMargin(direction)]) || 0;\n            const b = ((_b = this._metricsCache.get(k - 1)) === null || _b === void 0 ? void 0 : _b[trailingMargin(direction)]) || 0;\n            this._marginSizeCache.set(k, collapseMargins(a, b));\n        }\n    }\n    get averageChildSize() {\n        return this._childSizeCache.averageSize;\n    }\n    get totalChildSize() {\n        return this._childSizeCache.totalSize;\n    }\n    get averageMarginSize() {\n        return this._marginSizeCache.averageSize;\n    }\n    get totalMarginSize() {\n        return this._marginSizeCache.totalSize;\n    }\n    getLeadingMarginValue(index, direction) {\n        var _a;\n        return ((_a = this._metricsCache.get(index)) === null || _a === void 0 ? void 0 : _a[leadingMargin(direction)]) || 0;\n    }\n    getChildSize(index) {\n        return this._childSizeCache.getSize(index);\n    }\n    getMarginSize(index) {\n        return this._marginSizeCache.getSize(index);\n    }\n    clear() {\n        this._childSizeCache.clear();\n        this._marginSizeCache.clear();\n        this._metricsCache.clear();\n    }\n}\nexport class FlowLayout extends BaseLayout {\n    constructor() {\n        super(...arguments);\n        /**\n         * Initial estimate of item size\n         */\n        this._itemSize = { width: 100, height: 100 };\n        /**\n         * Indices of children mapped to their (position and length) in the scrolling\n         * direction. Used to keep track of children that are in range.\n         */\n        this._physicalItems = new Map();\n        /**\n         * Used in tandem with _physicalItems to track children in range across\n         * reflows.\n         */\n        this._newPhysicalItems = new Map();\n        /**\n         * Width and height of children by their index.\n         */\n        this._metricsCache = new MetricsCache();\n        /**\n         * anchorIdx is the anchor around which we reflow. It is designed to allow\n         * jumping to any point of the scroll size. We choose it once and stick with\n         * it until stable. _first and _last are deduced around it.\n         */\n        this._anchorIdx = null;\n        /**\n         * Position in the scrolling direction of the anchor child.\n         */\n        this._anchorPos = null;\n        /**\n         * Whether all children in range were in range during the previous reflow.\n         */\n        this._stable = true;\n        this._measureChildren = true;\n        this._estimate = true;\n    }\n    // protected _defaultConfig: BaseLayoutConfig = Object.assign({}, super._defaultConfig, {\n    // })\n    // constructor(config: Layout1dConfig) {\n    //   super(config);\n    // }\n    get measureChildren() {\n        return this._measureChildren;\n    }\n    /**\n     * Determine the average size of all children represented in the sizes\n     * argument.\n     */\n    updateItemSizes(sizes) {\n        this._metricsCache.update(sizes, this.direction);\n        // if (this._nMeasured) {\n        // this._updateItemSize();\n        this._scheduleReflow();\n        // }\n    }\n    /**\n     * Set the average item size based on the total length and number of children\n     * in range.\n     */\n    // _updateItemSize() {\n    //   // Keep integer values.\n    //   this._itemSize[this._sizeDim] = this._metricsCache.averageChildSize;\n    // }\n    _getPhysicalItem(idx) {\n        var _a;\n        return (_a = this._newPhysicalItems.get(idx)) !== null && _a !== void 0 ? _a : this._physicalItems.get(idx);\n    }\n    _getSize(idx) {\n        const item = this._getPhysicalItem(idx);\n        return item && this._metricsCache.getChildSize(idx);\n    }\n    _getAverageSize() {\n        return this._metricsCache.averageChildSize || this._itemSize[this._sizeDim];\n    }\n    /**\n     * Returns the position in the scrolling direction of the item at idx.\n     * Estimates it if the item at idx is not in the DOM.\n     */\n    _getPosition(idx) {\n        var _a;\n        const item = this._getPhysicalItem(idx);\n        const { averageMarginSize } = this._metricsCache;\n        return idx === 0\n            ? (_a = this._metricsCache.getMarginSize(0)) !== null && _a !== void 0 ? _a : averageMarginSize\n            : item\n                ? item.pos\n                : averageMarginSize + idx * (averageMarginSize + this._getAverageSize());\n    }\n    _calculateAnchor(lower, upper) {\n        if (lower <= 0) {\n            return 0;\n        }\n        if (upper > this._scrollSize - this._viewDim1) {\n            return this._totalItems - 1;\n        }\n        return Math.max(0, Math.min(this._totalItems - 1, Math.floor((lower + upper) / 2 / this._delta)));\n    }\n    _getAnchor(lower, upper) {\n        if (this._physicalItems.size === 0) {\n            return this._calculateAnchor(lower, upper);\n        }\n        if (this._first < 0) {\n            console.error('_getAnchor: negative _first');\n            return this._calculateAnchor(lower, upper);\n        }\n        if (this._last < 0) {\n            console.error('_getAnchor: negative _last');\n            return this._calculateAnchor(lower, upper);\n        }\n        const firstItem = this._getPhysicalItem(this._first), lastItem = this._getPhysicalItem(this._last), firstMin = firstItem.pos, lastMin = lastItem.pos, lastMax = lastMin + this._metricsCache.getChildSize(this._last);\n        if (lastMax < lower) {\n            // Window is entirely past physical items, calculate new anchor\n            return this._calculateAnchor(lower, upper);\n        }\n        if (firstMin > upper) {\n            // Window is entirely before physical items, calculate new anchor\n            return this._calculateAnchor(lower, upper);\n        }\n        // Window contains a physical item\n        // Find one, starting with the one that was previously first visible\n        let candidateIdx = this._firstVisible - 1;\n        let cMax = -Infinity;\n        while (cMax < lower) {\n            const candidate = this._getPhysicalItem(++candidateIdx);\n            cMax = candidate.pos + this._metricsCache.getChildSize(candidateIdx);\n        }\n        return candidateIdx;\n    }\n    /**\n     * Updates _first and _last based on items that should be in the current\n     * viewed range.\n     */\n    _getActiveItems() {\n        if (this._viewDim1 === 0 || this._totalItems === 0) {\n            this._clearItems();\n        }\n        else {\n            this._getItems();\n        }\n    }\n    /**\n     * Sets the range to empty.\n     */\n    _clearItems() {\n        this._first = -1;\n        this._last = -1;\n        this._physicalMin = 0;\n        this._physicalMax = 0;\n        const items = this._newPhysicalItems;\n        this._newPhysicalItems = this._physicalItems;\n        this._newPhysicalItems.clear();\n        this._physicalItems = items;\n        this._stable = true;\n    }\n    /*\n     * Updates _first and _last based on items that should be in the given range.\n     */\n    _getItems() {\n        var _a, _b;\n        const items = this._newPhysicalItems;\n        this._stable = true;\n        let lower, upper;\n        // The anchorIdx is the anchor around which we reflow. It is designed to\n        // allow jumping to any point of the scroll size. We choose it once and\n        // stick with it until stable. first and last are deduced around it.\n        // If we have a scrollToIndex, we anchor on the given\n        // index and set the scroll position accordingly\n        if (this._scrollToIndex >= 0) {\n            this._anchorIdx = Math.min(this._scrollToIndex, this._totalItems - 1);\n            this._anchorPos = this._getPosition(this._anchorIdx);\n            this._scrollIfNeeded();\n        }\n        // Determine the lower and upper bounds of the region to be\n        // rendered, relative to the viewport\n        lower = this._scrollPosition - this._overhang; //leadingOverhang;\n        upper = this._scrollPosition + this._viewDim1 + this._overhang; // trailingOverhang;\n        if (upper < 0 || lower > this._scrollSize) {\n            this._clearItems();\n            return;\n        }\n        // If we are scrolling to a specific index or if we are doing another\n        // pass to stabilize a previously started reflow, we will already\n        // have an anchor. If not, establish an anchor now.\n        if (this._anchorIdx === null || this._anchorPos === null) {\n            this._anchorIdx = this._getAnchor(lower, upper);\n            this._anchorPos = this._getPosition(this._anchorIdx);\n        }\n        let anchorSize = this._getSize(this._anchorIdx);\n        if (anchorSize === undefined) {\n            this._stable = false;\n            anchorSize = this._getAverageSize();\n        }\n        const anchorLeadingMargin = (_a = this._metricsCache.getMarginSize(this._anchorIdx)) !== null && _a !== void 0 ? _a : this._metricsCache.averageMarginSize;\n        const anchorTrailingMargin = (_b = this._metricsCache.getMarginSize(this._anchorIdx + 1)) !== null && _b !== void 0 ? _b : this._metricsCache.averageMarginSize;\n        if (this._anchorIdx === 0) {\n            this._anchorPos = anchorLeadingMargin;\n        }\n        if (this._anchorIdx === this._totalItems - 1) {\n            this._anchorPos = this._scrollSize - anchorTrailingMargin - anchorSize;\n        }\n        // Anchor might be outside bounds, so prefer correcting the error and keep\n        // that anchorIdx.\n        let anchorErr = 0;\n        if (this._anchorPos + anchorSize + anchorTrailingMargin < lower) {\n            anchorErr = lower - (this._anchorPos + anchorSize + anchorTrailingMargin);\n        }\n        if (this._anchorPos - anchorLeadingMargin > upper) {\n            anchorErr = upper - (this._anchorPos - anchorLeadingMargin);\n        }\n        if (anchorErr) {\n            this._scrollPosition -= anchorErr;\n            lower -= anchorErr;\n            upper -= anchorErr;\n            this._scrollError += anchorErr;\n        }\n        items.set(this._anchorIdx, { pos: this._anchorPos, size: anchorSize });\n        this._first = this._last = this._anchorIdx;\n        this._physicalMin = this._anchorPos - anchorLeadingMargin;\n        this._physicalMax = this._anchorPos + anchorSize + anchorTrailingMargin;\n        while (this._physicalMin > lower && this._first > 0) {\n            let size = this._getSize(--this._first);\n            if (size === undefined) {\n                this._stable = false;\n                size = this._getAverageSize();\n            }\n            let margin = this._metricsCache.getMarginSize(this._first);\n            if (margin === undefined) {\n                this._stable = false;\n                margin = this._metricsCache.averageMarginSize;\n            }\n            this._physicalMin -= size;\n            const pos = this._physicalMin;\n            items.set(this._first, { pos, size });\n            this._physicalMin -= margin;\n            if (this._stable === false && this._estimate === false) {\n                break;\n            }\n        }\n        while (this._physicalMax < upper && this._last < this._totalItems - 1) {\n            let size = this._getSize(++this._last);\n            if (size === undefined) {\n                this._stable = false;\n                size = this._getAverageSize();\n            }\n            let margin = this._metricsCache.getMarginSize(this._last);\n            if (margin === undefined) {\n                this._stable = false;\n                margin = this._metricsCache.averageMarginSize;\n            }\n            const pos = this._physicalMax;\n            items.set(this._last, { pos, size });\n            this._physicalMax += size + margin;\n            if (!this._stable && !this._estimate) {\n                break;\n            }\n        }\n        // This handles the cases where we were relying on estimated sizes.\n        const extentErr = this._calculateError();\n        if (extentErr) {\n            this._physicalMin -= extentErr;\n            this._physicalMax -= extentErr;\n            this._anchorPos -= extentErr;\n            this._scrollPosition -= extentErr;\n            items.forEach((item) => (item.pos -= extentErr));\n            this._scrollError += extentErr;\n        }\n        if (this._stable) {\n            this._newPhysicalItems = this._physicalItems;\n            this._newPhysicalItems.clear();\n            this._physicalItems = items;\n        }\n    }\n    _calculateError() {\n        if (this._first === 0) {\n            return this._physicalMin;\n        }\n        else if (this._physicalMin <= 0) {\n            return this._physicalMin - this._first * this._delta;\n        }\n        else if (this._last === this._totalItems - 1) {\n            return this._physicalMax - this._scrollSize;\n        }\n        else if (this._physicalMax >= this._scrollSize) {\n            return (this._physicalMax -\n                this._scrollSize +\n                (this._totalItems - 1 - this._last) * this._delta);\n        }\n        return 0;\n    }\n    // TODO: Can this be made to inherit from base, with proper hooks?\n    _reflow() {\n        const { _first, _last, _scrollSize } = this;\n        this._updateScrollSize();\n        this._getActiveItems();\n        if (this._scrollSize !== _scrollSize) {\n            this._emitScrollSize();\n        }\n        this._updateVisibleIndices();\n        this._emitRange();\n        if (this._first === -1 && this._last === -1) {\n            this._resetReflowState();\n        }\n        else if (this._first !== _first || this._last !== _last) {\n            this._emitChildPositions();\n            this._emitScrollError();\n        }\n        else {\n            this._emitChildPositions();\n            this._emitScrollError();\n            this._resetReflowState();\n        }\n    }\n    _resetReflowState() {\n        this._anchorIdx = null;\n        this._anchorPos = null;\n        this._stable = true;\n    }\n    _updateScrollSize() {\n        const { averageMarginSize } = this._metricsCache;\n        this._scrollSize = Math.max(1, this._totalItems * (averageMarginSize + this._getAverageSize()) +\n            averageMarginSize);\n    }\n    /**\n     * Returns the average size (precise or estimated) of an item in the scrolling direction,\n     * including any surrounding space.\n     */\n    get _delta() {\n        const { averageMarginSize } = this._metricsCache;\n        return this._getAverageSize() + averageMarginSize;\n    }\n    /**\n     * Returns the top and left positioning of the item at idx.\n     */\n    _getItemPosition(idx) {\n        var _a;\n        return {\n            [this._positionDim]: this._getPosition(idx),\n            [this._secondaryPositionDim]: 0,\n            [offset(this.direction)]: -((_a = this._metricsCache.getLeadingMarginValue(idx, this.direction)) !== null && _a !== void 0 ? _a : this._metricsCache.averageMarginSize),\n        };\n    }\n    /**\n     * Returns the height and width of the item at idx.\n     */\n    _getItemSize(idx) {\n        var _a;\n        return {\n            [this._sizeDim]: (this._getSize(idx) || this._getAverageSize()) +\n                ((_a = this._metricsCache.getMarginSize(idx + 1)) !== null && _a !== void 0 ? _a : this._metricsCache.averageMarginSize),\n            [this._secondarySizeDim]: this._itemSize[this._secondarySizeDim],\n        };\n    }\n    _viewDim2Changed() {\n        this._scheduleReflow();\n    }\n}\n//# sourceMappingURL=flow.js.map","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport EventTarget from '../../polyfillLoaders/EventTarget.js';\nexport function dim1(direction) {\n    return direction === 'horizontal' ? 'width' : 'height';\n}\nexport function dim2(direction) {\n    return direction === 'horizontal' ? 'height' : 'width';\n}\nexport function pos1(direction) {\n    return direction === 'horizontal' ? 'left' : 'top';\n}\nexport function pos2(direction) {\n    return direction === 'horizontal' ? 'top' : 'left';\n}\nexport class BaseLayout {\n    constructor(config) {\n        /**\n         * The last set viewport scroll position.\n         */\n        this._latestCoords = { left: 0, top: 0 };\n        /**\n         * Scrolling direction.\n         */\n        this._direction = null;\n        /**\n         * Dimensions of the viewport.\n         */\n        this._viewportSize = { width: 0, height: 0 };\n        /**\n         * Flag for debouncing asynchnronous reflow requests.\n         */\n        this._pendingReflow = false;\n        this._pendingLayoutUpdate = false;\n        /**\n         * Index of the item that has been scrolled to via the public API. When the\n         * viewport is otherwise scrolled, this value is set back to -1.\n         */\n        this._scrollToIndex = -1;\n        /**\n         * When a child is scrolled to, the offset from the top of the child and the\n         * top of the viewport. Value is a proportion of the item size.\n         */\n        this._scrollToAnchor = 0;\n        /**\n         * The index of the first item intersecting the viewport.\n         */\n        this._firstVisible = 0;\n        /**\n         * The index of the last item intersecting the viewport.\n         */\n        this._lastVisible = 0;\n        this._eventTargetPromise = EventTarget().then((Ctor) => {\n            this._eventTarget = new Ctor();\n        });\n        /**\n         * Pixel offset in the scroll direction of the first child.\n         */\n        this._physicalMin = 0;\n        /**\n         * Pixel offset in the scroll direction of the last child.\n         */\n        this._physicalMax = 0;\n        /**\n         * Index of the first child.\n         */\n        this._first = -1;\n        /**\n         * Index of the last child.\n         */\n        this._last = -1;\n        /**\n         * Length in the scrolling direction.\n         */\n        this._sizeDim = 'height';\n        /**\n         * Length in the non-scrolling direction.\n         */\n        this._secondarySizeDim = 'width';\n        /**\n         * Position in the scrolling direction.\n         */\n        this._positionDim = 'top';\n        /**\n         * Position in the non-scrolling direction.\n         */\n        this._secondaryPositionDim = 'left';\n        /**\n         * Current scroll offset in pixels.\n         */\n        this._scrollPosition = 0;\n        /**\n         * Difference between current scroll offset and scroll offset calculated due\n         * to a reflow.\n         */\n        this._scrollError = 0;\n        /**\n         * Total number of items that could possibly be displayed. Used to help\n         * calculate the scroll size.\n         */\n        this._totalItems = 0;\n        /**\n         * The total (estimated) length of all items in the scrolling direction.\n         */\n        this._scrollSize = 1;\n        /**\n         * Number of pixels beyond the viewport to still include\n         * in the active range of items.\n         */\n        // TODO (graynorton): Probably want to make this something we calculate based\n        // on viewport size, item size, other factors, possibly still with a dial of some kind\n        this._overhang = 1000;\n        this._eventTarget = null;\n        // Delay setting config so that subclasses do setup work first\n        Promise.resolve().then(() => (this.config = config || this._defaultConfig));\n    }\n    get _defaultConfig() {\n        return {\n            direction: 'vertical',\n        };\n    }\n    set config(config) {\n        Object.assign(this, Object.assign({}, this._defaultConfig, config));\n    }\n    get config() {\n        return {\n            direction: this.direction,\n        };\n    }\n    /**\n     * Maximum index of children + 1, to help estimate total height of the scroll\n     * space.\n     */\n    get totalItems() {\n        return this._totalItems;\n    }\n    set totalItems(num) {\n        const _num = Number(num);\n        if (_num !== this._totalItems) {\n            this._totalItems = _num;\n            this._scheduleReflow();\n        }\n    }\n    /**\n     * Primary scrolling direction.\n     */\n    get direction() {\n        return this._direction;\n    }\n    set direction(dir) {\n        // Force it to be either horizontal or vertical.\n        dir = dir === 'horizontal' ? dir : 'vertical';\n        if (dir !== this._direction) {\n            this._direction = dir;\n            this._sizeDim = dir === 'horizontal' ? 'width' : 'height';\n            this._secondarySizeDim = dir === 'horizontal' ? 'height' : 'width';\n            this._positionDim = dir === 'horizontal' ? 'left' : 'top';\n            this._secondaryPositionDim = dir === 'horizontal' ? 'top' : 'left';\n            this._triggerReflow();\n        }\n    }\n    /**\n     * Height and width of the viewport.\n     */\n    get viewportSize() {\n        return this._viewportSize;\n    }\n    set viewportSize(dims) {\n        const { _viewDim1, _viewDim2 } = this;\n        Object.assign(this._viewportSize, dims);\n        if (_viewDim2 !== this._viewDim2) {\n            // this._viewDim2Changed();\n            this._scheduleLayoutUpdate();\n        }\n        else if (_viewDim1 !== this._viewDim1) {\n            this._checkThresholds();\n        }\n    }\n    /**\n     * Scroll offset of the viewport.\n     */\n    get viewportScroll() {\n        return this._latestCoords;\n    }\n    set viewportScroll(coords) {\n        Object.assign(this._latestCoords, coords);\n        const oldPos = this._scrollPosition;\n        this._scrollPosition = this._latestCoords[this._positionDim];\n        if (oldPos !== this._scrollPosition) {\n            this._scrollPositionChanged(oldPos, this._scrollPosition);\n            this._updateVisibleIndices({ emit: true });\n        }\n        this._checkThresholds();\n    }\n    /**\n     * Perform a reflow if one has been scheduled.\n     */\n    reflowIfNeeded(force = false) {\n        if (force || this._pendingReflow) {\n            this._pendingReflow = false;\n            this._reflow();\n        }\n    }\n    /**\n     * Scroll to the child at the given index, and the given position within that\n     * child.\n     */\n    scrollToIndex(index, position = 'start') {\n        if (!Number.isFinite(index))\n            return;\n        index = Math.min(this.totalItems, Math.max(0, index));\n        this._scrollToIndex = index;\n        if (position === 'nearest') {\n            position = index > this._first + this._num / 2 ? 'end' : 'start';\n        }\n        switch (position) {\n            case 'start':\n                this._scrollToAnchor = 0;\n                break;\n            case 'center':\n                this._scrollToAnchor = 0.5;\n                break;\n            case 'end':\n                this._scrollToAnchor = 1;\n                break;\n            default:\n                throw new TypeError('position must be one of: start, center, end, nearest');\n        }\n        this._scheduleReflow();\n    }\n    async dispatchEvent(evt) {\n        await this._eventTargetPromise;\n        this._eventTarget.dispatchEvent(evt);\n    }\n    async addEventListener(type, listener, options) {\n        await this._eventTargetPromise;\n        this._eventTarget.addEventListener(type, listener, options);\n    }\n    async removeEventListener(type, callback, options) {\n        await this._eventTargetPromise;\n        this._eventTarget.removeEventListener(type, callback, options);\n    }\n    _updateLayout() {\n        // Override\n    }\n    // protected _viewDim2Changed(): void {\n    //   this._scheduleLayoutUpdate();\n    // }\n    /**\n     * The height or width of the viewport, whichever corresponds to the scrolling direction.\n     */\n    get _viewDim1() {\n        return this._viewportSize[this._sizeDim];\n    }\n    /**\n     * The height or width of the viewport, whichever does NOT correspond to the scrolling direction.\n     */\n    get _viewDim2() {\n        return this._viewportSize[this._secondarySizeDim];\n    }\n    _scheduleReflow() {\n        this._pendingReflow = true;\n    }\n    _scheduleLayoutUpdate() {\n        this._pendingLayoutUpdate = true;\n        this._scheduleReflow();\n    }\n    // For triggering a reflow based on incoming changes to\n    // the layout config.\n    _triggerReflow() {\n        this._scheduleLayoutUpdate();\n        // TODO graynorton@: reflowIfNeeded() isn't really supposed\n        // to be called internally. Address in larger cleanup\n        // of virtualizer / layout interaction pattern.\n        // this.reflowIfNeeded(true);\n        Promise.resolve().then(() => this.reflowIfNeeded());\n    }\n    _reflow() {\n        if (this._pendingLayoutUpdate) {\n            this._updateLayout();\n            this._pendingLayoutUpdate = false;\n        }\n        this._updateScrollSize();\n        this._getActiveItems();\n        this._scrollIfNeeded();\n        this._updateVisibleIndices();\n        this._emitScrollSize();\n        this._emitRange();\n        this._emitChildPositions();\n        this._emitScrollError();\n    }\n    _scrollIfNeeded() {\n        if (this._scrollToIndex === -1) {\n            return;\n        }\n        const index = this._scrollToIndex;\n        const anchor = this._scrollToAnchor;\n        const pos = this._getItemPosition(index)[this._positionDim];\n        const size = this._getItemSize(index)[this._sizeDim];\n        const curAnchorPos = this._scrollPosition + this._viewDim1 * anchor;\n        const newAnchorPos = pos + size * anchor;\n        // Ensure scroll position is an integer within scroll bounds.\n        const scrollPosition = Math.floor(Math.min(this._scrollSize - this._viewDim1, Math.max(0, this._scrollPosition - curAnchorPos + newAnchorPos)));\n        this._scrollError += this._scrollPosition - scrollPosition;\n        this._scrollPosition = scrollPosition;\n    }\n    _emitRange(inProps = undefined) {\n        const detail = Object.assign({\n            first: this._first,\n            last: this._last,\n            num: this._num,\n            firstVisible: this._firstVisible,\n            lastVisible: this._lastVisible,\n        }, inProps);\n        this.dispatchEvent(new CustomEvent('rangechange', { detail }));\n    }\n    _emitScrollSize() {\n        const detail = {\n            [this._sizeDim]: this._scrollSize,\n            [this._secondarySizeDim]: null,\n        };\n        this.dispatchEvent(new CustomEvent('scrollsizechange', { detail }));\n    }\n    _emitScrollError() {\n        if (this._scrollError) {\n            const detail = {\n                [this._positionDim]: this._scrollError,\n                [this._secondaryPositionDim]: 0,\n            };\n            this.dispatchEvent(new CustomEvent('scrollerrorchange', { detail }));\n            this._scrollError = 0;\n        }\n    }\n    /**\n     * Get or estimate the top and left positions of items in the current range.\n     * Emit an itempositionchange event with these positions.\n     */\n    _emitChildPositions() {\n        const detail = {};\n        for (let idx = this._first; idx <= this._last; idx++) {\n            detail[idx] = this._getItemPosition(idx);\n        }\n        this.dispatchEvent(new CustomEvent('itempositionchange', { detail }));\n    }\n    /**\n     * Number of items to display.\n     */\n    get _num() {\n        if (this._first === -1 || this._last === -1) {\n            return 0;\n        }\n        return this._last - this._first + 1;\n    }\n    _checkThresholds() {\n        if (this._viewDim1 === 0 && this._num > 0) {\n            this._scheduleReflow();\n        }\n        else {\n            const min = Math.max(0, this._scrollPosition - this._overhang);\n            const max = Math.min(this._scrollSize, this._scrollPosition + this._viewDim1 + this._overhang);\n            if (this._physicalMin > min || this._physicalMax < max) {\n                this._scheduleReflow();\n            }\n        }\n    }\n    /**\n     * Find the indices of the first and last items to intersect the viewport.\n     * Emit a visibleindiceschange event when either index changes.\n     */\n    _updateVisibleIndices(options) {\n        if (this._first === -1 || this._last === -1)\n            return;\n        let firstVisible = this._first;\n        while (firstVisible < this._last &&\n            Math.round(this._getItemPosition(firstVisible)[this._positionDim] +\n                this._getItemSize(firstVisible)[this._sizeDim]) <= Math.round(this._scrollPosition)) {\n            firstVisible++;\n        }\n        let lastVisible = this._last;\n        while (lastVisible > this._first &&\n            Math.round(this._getItemPosition(lastVisible)[this._positionDim]) >=\n                Math.round(this._scrollPosition + this._viewDim1)) {\n            lastVisible--;\n        }\n        if (firstVisible !== this._firstVisible ||\n            lastVisible !== this._lastVisible) {\n            this._firstVisible = firstVisible;\n            this._lastVisible = lastVisible;\n            if (options && options.emit) {\n                this._emitRange();\n            }\n        }\n    }\n    _scrollPositionChanged(oldPos, newPos) {\n        // When both values are bigger than the max scroll position, keep the\n        // current _scrollToIndex, otherwise invalidate it.\n        const maxPos = this._scrollSize - this._viewDim1;\n        if (oldPos < maxPos || newPos < maxPos) {\n            this._scrollToIndex = -1;\n        }\n    }\n}\n//# sourceMappingURL=BaseLayout.js.map"],"names":["constructor","config","this","roundAverageSize","_roundAverageSize","set","index","value","_map","get","totalSize","prev","averageSize","size","Math","round","average","getSize","clear","async","_ET","window","EventTarget","init","flow","Object","assign","type","FlowLayout","direction","a","b","sort","min","m","max","update","metrics","keys","forEach","key","Number","_metricsCache","k","_childSizeCache","dim1","marginsToUpdate","add","_a","leadingMargin","_b","trailingMargin","_marginSizeCache","collapseMargins","averageChildSize","totalChildSize","averageMarginSize","totalMarginSize","getLeadingMarginValue","getChildSize","getMarginSize","left","top","width","height","then","Ctor","_eventTarget","Promise","resolve","_defaultConfig","totalItems","_totalItems","num","_num","_scheduleReflow","_direction","dir","_sizeDim","_secondarySizeDim","_positionDim","_secondaryPositionDim","_triggerReflow","viewportSize","_viewportSize","dims","_viewDim1","_viewDim2","_scheduleLayoutUpdate","_checkThresholds","viewportScroll","_latestCoords","coords","_scrollPosition","oldPos","_scrollPositionChanged","_updateVisibleIndices","emit","reflowIfNeeded","force","_pendingReflow","_reflow","scrollToIndex","position","isFinite","_scrollToIndex","_first","_scrollToAnchor","[object Object]","evt","_eventTargetPromise","dispatchEvent","listener","options","addEventListener","callback","removeEventListener","_updateLayout","_pendingLayoutUpdate","_updateScrollSize","_getActiveItems","_scrollIfNeeded","_emitScrollSize","_emitRange","_emitChildPositions","_emitScrollError","_getItemPosition","_getItemSize","anchor","pos","floor","_scrollSize","curAnchorPos","newAnchorPos","_scrollError","scrollPosition","inProps","first","last","_last","firstVisible","_firstVisible","lastVisible","_lastVisible","detail","idx","_overhang","_physicalMin","_physicalMax","newPos","maxPos","measureChildren","_measureChildren","updateItemSizes","sizes","_getPhysicalItem","_newPhysicalItems","_physicalItems","_getSize","_getAverageSize","_itemSize","_getPosition","item","_calculateAnchor","lower","upper","_delta","_getAnchor","console","error","lastItem","firstMin","firstItem","Infinity","cMax","candidateIdx","_clearItems","_getItems","items","_stable","_anchorIdx","_anchorPos","undefined","anchorSize","anchorLeadingMargin","anchorTrailingMargin","anchorErr","margin","_estimate","_calculateError","extentErr","_resetReflowState","_viewDim2Changed"],"mappings":"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"}
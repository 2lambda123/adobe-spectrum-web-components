{"version":3,"file":"0b054011.js","sources":["../../../node_modules/@lit-labs/virtualizer/polyfillLoaders/EventTarget.js","../../../node_modules/@lit-labs/virtualizer/layouts/shared/BaseLayout.js"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nlet _ET;\nlet ET;\nexport default async function EventTarget() {\n    return ET || init();\n}\nasync function init() {\n    _ET = window.EventTarget;\n    try {\n        new _ET();\n    }\n    catch {\n        _ET = (await import('event-target-shim')).EventTarget;\n    }\n    return (ET = _ET);\n}\n//# sourceMappingURL=EventTarget.js.map","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport EventTarget from '../../polyfillLoaders/EventTarget.js';\nexport function dim1(direction) {\n    return direction === 'horizontal' ? 'width' : 'height';\n}\nexport function dim2(direction) {\n    return direction === 'horizontal' ? 'height' : 'width';\n}\nexport function pos1(direction) {\n    return direction === 'horizontal' ? 'left' : 'top';\n}\nexport function pos2(direction) {\n    return direction === 'horizontal' ? 'top' : 'left';\n}\nexport class BaseLayout {\n    constructor(config) {\n        /**\n         * The last set viewport scroll position.\n         */\n        this._latestCoords = { left: 0, top: 0 };\n        /**\n         * Scrolling direction.\n         */\n        this._direction = null;\n        /**\n         * Dimensions of the viewport.\n         */\n        this._viewportSize = { width: 0, height: 0 };\n        /**\n         * Flag for debouncing asynchnronous reflow requests.\n         */\n        this._pendingReflow = false;\n        this._pendingLayoutUpdate = false;\n        /**\n         * Index of the item that has been scrolled to via the public API. When the\n         * viewport is otherwise scrolled, this value is set back to -1.\n         */\n        this._scrollToIndex = -1;\n        /**\n         * When a child is scrolled to, the offset from the top of the child and the\n         * top of the viewport. Value is a proportion of the item size.\n         */\n        this._scrollToAnchor = 0;\n        /**\n         * The index of the first item intersecting the viewport.\n         */\n        this._firstVisible = 0;\n        /**\n         * The index of the last item intersecting the viewport.\n         */\n        this._lastVisible = 0;\n        this._eventTargetPromise = EventTarget().then((Ctor) => {\n            this._eventTarget = new Ctor();\n        });\n        /**\n         * Pixel offset in the scroll direction of the first child.\n         */\n        this._physicalMin = 0;\n        /**\n         * Pixel offset in the scroll direction of the last child.\n         */\n        this._physicalMax = 0;\n        /**\n         * Index of the first child.\n         */\n        this._first = -1;\n        /**\n         * Index of the last child.\n         */\n        this._last = -1;\n        /**\n         * Length in the scrolling direction.\n         */\n        this._sizeDim = 'height';\n        /**\n         * Length in the non-scrolling direction.\n         */\n        this._secondarySizeDim = 'width';\n        /**\n         * Position in the scrolling direction.\n         */\n        this._positionDim = 'top';\n        /**\n         * Position in the non-scrolling direction.\n         */\n        this._secondaryPositionDim = 'left';\n        /**\n         * Current scroll offset in pixels.\n         */\n        this._scrollPosition = 0;\n        /**\n         * Difference between current scroll offset and scroll offset calculated due\n         * to a reflow.\n         */\n        this._scrollError = 0;\n        /**\n         * Total number of items that could possibly be displayed. Used to help\n         * calculate the scroll size.\n         */\n        this._totalItems = 0;\n        /**\n         * The total (estimated) length of all items in the scrolling direction.\n         */\n        this._scrollSize = 1;\n        /**\n         * Number of pixels beyond the viewport to still include\n         * in the active range of items.\n         */\n        // TODO (graynorton): Probably want to make this something we calculate based\n        // on viewport size, item size, other factors, possibly still with a dial of some kind\n        this._overhang = 1000;\n        this._eventTarget = null;\n        // Delay setting config so that subclasses do setup work first\n        Promise.resolve().then(() => (this.config = config || this._defaultConfig));\n    }\n    get _defaultConfig() {\n        return {\n            direction: 'vertical',\n        };\n    }\n    set config(config) {\n        Object.assign(this, Object.assign({}, this._defaultConfig, config));\n    }\n    get config() {\n        return {\n            direction: this.direction,\n        };\n    }\n    /**\n     * Maximum index of children + 1, to help estimate total height of the scroll\n     * space.\n     */\n    get totalItems() {\n        return this._totalItems;\n    }\n    set totalItems(num) {\n        const _num = Number(num);\n        if (_num !== this._totalItems) {\n            this._totalItems = _num;\n            this._scheduleReflow();\n        }\n    }\n    /**\n     * Primary scrolling direction.\n     */\n    get direction() {\n        return this._direction;\n    }\n    set direction(dir) {\n        // Force it to be either horizontal or vertical.\n        dir = dir === 'horizontal' ? dir : 'vertical';\n        if (dir !== this._direction) {\n            this._direction = dir;\n            this._sizeDim = dir === 'horizontal' ? 'width' : 'height';\n            this._secondarySizeDim = dir === 'horizontal' ? 'height' : 'width';\n            this._positionDim = dir === 'horizontal' ? 'left' : 'top';\n            this._secondaryPositionDim = dir === 'horizontal' ? 'top' : 'left';\n            this._triggerReflow();\n        }\n    }\n    /**\n     * Height and width of the viewport.\n     */\n    get viewportSize() {\n        return this._viewportSize;\n    }\n    set viewportSize(dims) {\n        const { _viewDim1, _viewDim2 } = this;\n        Object.assign(this._viewportSize, dims);\n        if (_viewDim2 !== this._viewDim2) {\n            // this._viewDim2Changed();\n            this._scheduleLayoutUpdate();\n        }\n        else if (_viewDim1 !== this._viewDim1) {\n            this._checkThresholds();\n        }\n    }\n    /**\n     * Scroll offset of the viewport.\n     */\n    get viewportScroll() {\n        return this._latestCoords;\n    }\n    set viewportScroll(coords) {\n        Object.assign(this._latestCoords, coords);\n        const oldPos = this._scrollPosition;\n        this._scrollPosition = this._latestCoords[this._positionDim];\n        if (oldPos !== this._scrollPosition) {\n            this._scrollPositionChanged(oldPos, this._scrollPosition);\n            this._updateVisibleIndices({ emit: true });\n        }\n        this._checkThresholds();\n    }\n    /**\n     * Perform a reflow if one has been scheduled.\n     */\n    reflowIfNeeded(force = false) {\n        if (force || this._pendingReflow) {\n            this._pendingReflow = false;\n            this._reflow();\n        }\n    }\n    /**\n     * Scroll to the child at the given index, and the given position within that\n     * child.\n     */\n    scrollToIndex(index, position = 'start') {\n        if (!Number.isFinite(index))\n            return;\n        index = Math.min(this.totalItems, Math.max(0, index));\n        this._scrollToIndex = index;\n        if (position === 'nearest') {\n            position = index > this._first + this._num / 2 ? 'end' : 'start';\n        }\n        switch (position) {\n            case 'start':\n                this._scrollToAnchor = 0;\n                break;\n            case 'center':\n                this._scrollToAnchor = 0.5;\n                break;\n            case 'end':\n                this._scrollToAnchor = 1;\n                break;\n            default:\n                throw new TypeError('position must be one of: start, center, end, nearest');\n        }\n        this._scheduleReflow();\n    }\n    async dispatchEvent(evt) {\n        await this._eventTargetPromise;\n        this._eventTarget.dispatchEvent(evt);\n    }\n    async addEventListener(type, listener, options) {\n        await this._eventTargetPromise;\n        this._eventTarget.addEventListener(type, listener, options);\n    }\n    async removeEventListener(type, callback, options) {\n        await this._eventTargetPromise;\n        this._eventTarget.removeEventListener(type, callback, options);\n    }\n    _updateLayout() {\n        // Override\n    }\n    // protected _viewDim2Changed(): void {\n    //   this._scheduleLayoutUpdate();\n    // }\n    /**\n     * The height or width of the viewport, whichever corresponds to the scrolling direction.\n     */\n    get _viewDim1() {\n        return this._viewportSize[this._sizeDim];\n    }\n    /**\n     * The height or width of the viewport, whichever does NOT correspond to the scrolling direction.\n     */\n    get _viewDim2() {\n        return this._viewportSize[this._secondarySizeDim];\n    }\n    _scheduleReflow() {\n        this._pendingReflow = true;\n    }\n    _scheduleLayoutUpdate() {\n        this._pendingLayoutUpdate = true;\n        this._scheduleReflow();\n    }\n    // For triggering a reflow based on incoming changes to\n    // the layout config.\n    _triggerReflow() {\n        this._scheduleLayoutUpdate();\n        // TODO graynorton@: reflowIfNeeded() isn't really supposed\n        // to be called internally. Address in larger cleanup\n        // of virtualizer / layout interaction pattern.\n        // this.reflowIfNeeded(true);\n        Promise.resolve().then(() => this.reflowIfNeeded());\n    }\n    _reflow() {\n        if (this._pendingLayoutUpdate) {\n            this._updateLayout();\n            this._pendingLayoutUpdate = false;\n        }\n        this._updateScrollSize();\n        this._getActiveItems();\n        this._scrollIfNeeded();\n        this._updateVisibleIndices();\n        this._emitScrollSize();\n        this._emitRange();\n        this._emitChildPositions();\n        this._emitScrollError();\n    }\n    _scrollIfNeeded() {\n        if (this._scrollToIndex === -1) {\n            return;\n        }\n        const index = this._scrollToIndex;\n        const anchor = this._scrollToAnchor;\n        const pos = this._getItemPosition(index)[this._positionDim];\n        const size = this._getItemSize(index)[this._sizeDim];\n        const curAnchorPos = this._scrollPosition + this._viewDim1 * anchor;\n        const newAnchorPos = pos + size * anchor;\n        // Ensure scroll position is an integer within scroll bounds.\n        const scrollPosition = Math.floor(Math.min(this._scrollSize - this._viewDim1, Math.max(0, this._scrollPosition - curAnchorPos + newAnchorPos)));\n        this._scrollError += this._scrollPosition - scrollPosition;\n        this._scrollPosition = scrollPosition;\n    }\n    _emitRange(inProps = undefined) {\n        const detail = Object.assign({\n            first: this._first,\n            last: this._last,\n            num: this._num,\n            firstVisible: this._firstVisible,\n            lastVisible: this._lastVisible,\n        }, inProps);\n        this.dispatchEvent(new CustomEvent('rangechange', { detail }));\n    }\n    _emitScrollSize() {\n        const detail = {\n            [this._sizeDim]: this._scrollSize,\n            [this._secondarySizeDim]: null,\n        };\n        this.dispatchEvent(new CustomEvent('scrollsizechange', { detail }));\n    }\n    _emitScrollError() {\n        if (this._scrollError) {\n            const detail = {\n                [this._positionDim]: this._scrollError,\n                [this._secondaryPositionDim]: 0,\n            };\n            this.dispatchEvent(new CustomEvent('scrollerrorchange', { detail }));\n            this._scrollError = 0;\n        }\n    }\n    /**\n     * Get or estimate the top and left positions of items in the current range.\n     * Emit an itempositionchange event with these positions.\n     */\n    _emitChildPositions() {\n        const detail = {};\n        for (let idx = this._first; idx <= this._last; idx++) {\n            detail[idx] = this._getItemPosition(idx);\n        }\n        this.dispatchEvent(new CustomEvent('itempositionchange', { detail }));\n    }\n    /**\n     * Number of items to display.\n     */\n    get _num() {\n        if (this._first === -1 || this._last === -1) {\n            return 0;\n        }\n        return this._last - this._first + 1;\n    }\n    _checkThresholds() {\n        if (this._viewDim1 === 0 && this._num > 0) {\n            this._scheduleReflow();\n        }\n        else {\n            const min = Math.max(0, this._scrollPosition - this._overhang);\n            const max = Math.min(this._scrollSize, this._scrollPosition + this._viewDim1 + this._overhang);\n            if (this._physicalMin > min || this._physicalMax < max) {\n                this._scheduleReflow();\n            }\n        }\n    }\n    /**\n     * Find the indices of the first and last items to intersect the viewport.\n     * Emit a visibleindiceschange event when either index changes.\n     */\n    _updateVisibleIndices(options) {\n        if (this._first === -1 || this._last === -1)\n            return;\n        let firstVisible = this._first;\n        while (firstVisible < this._last &&\n            Math.round(this._getItemPosition(firstVisible)[this._positionDim] +\n                this._getItemSize(firstVisible)[this._sizeDim]) <= Math.round(this._scrollPosition)) {\n            firstVisible++;\n        }\n        let lastVisible = this._last;\n        while (lastVisible > this._first &&\n            Math.round(this._getItemPosition(lastVisible)[this._positionDim]) >=\n                Math.round(this._scrollPosition + this._viewDim1)) {\n            lastVisible--;\n        }\n        if (firstVisible !== this._firstVisible ||\n            lastVisible !== this._lastVisible) {\n            this._firstVisible = firstVisible;\n            this._lastVisible = lastVisible;\n            if (options && options.emit) {\n                this._emitRange();\n            }\n        }\n    }\n    _scrollPositionChanged(oldPos, newPos) {\n        // When both values are bigger than the max scroll position, keep the\n        // current _scrollToIndex, otherwise invalidate it.\n        const maxPos = this._scrollSize - this._viewDim1;\n        if (oldPos < maxPos || newPos < maxPos) {\n            this._scrollToIndex = -1;\n        }\n    }\n}\n//# sourceMappingURL=BaseLayout.js.map"],"names":["async","_ET","window","EventTarget","init","direction","constructor","config","this","left","top","width","height","then","Ctor","_eventTarget","Promise","resolve","_defaultConfig","Object","assign","_totalItems","num","Number","_num","_scheduleReflow","_direction","dir","_sizeDim","_secondarySizeDim","_positionDim","_secondaryPositionDim","_triggerReflow","_viewportSize","dims","_viewDim1","_viewDim2","_scheduleLayoutUpdate","_checkThresholds","_latestCoords","coords","_scrollPosition","oldPos","_scrollPositionChanged","_updateVisibleIndices","emit","reflowIfNeeded","force","_pendingReflow","_reflow","scrollToIndex","index","position","isFinite","Math","min","totalItems","max","_scrollToIndex","_first","_scrollToAnchor","evt","_eventTargetPromise","dispatchEvent","type","listener","options","addEventListener","callback","removeEventListener","_updateLayout","_pendingLayoutUpdate","_updateScrollSize","_getActiveItems","_scrollIfNeeded","_emitScrollSize","_emitRange","_emitChildPositions","_emitScrollError","_getItemPosition","_getItemSize","anchor","pos","size","floor","_scrollSize","curAnchorPos","newAnchorPos","_scrollError","scrollPosition","inProps","first","last","_last","firstVisible","_firstVisible","lastVisible","_lastVisible","detail","idx","_overhang","_physicalMin","_physicalMax","round","newPos","maxPos"],"mappings":"AAYA,2BAIE,UAGFA,iBACEC,EAAMC,OAAOC,YACb,IACE,KAGD,CAFC,MACAF,gBAAoB,kBAAsBE,WAC3C,CACD,SAAaF,CACd,CAXcG,EACd,YCOoBC,GACnB,MAAqB,iBAAe,QAAU,QAC/C,YAEoBA,GACnB,MAAqB,iBAAe,SAAW,OAChD,SAyICC,YAAYC,GA3HJC,mBAA2B,CAACC,KAAM,EAAGC,IAAK,GAK1CF,gBAAqC,KAKrCA,mBAAsB,CAACG,MAAO,EAAGC,OAAQ,GAKzCJ,qBAAiB,EAEjBA,2BAAuB,EAMrBA,qBAAkB,EAMpBA,qBAAkB,EAKhBA,mBAAgB,EAKhBA,kBAAe,EAEjBA,yBAAqCL,IAAcU,MAAMC,IAC/DN,KAAKO,aAAe,KAApB,IAMQP,kBAAe,EAKfA,kBAAe,EAKfA,aAAU,EAKVA,YAAS,EAKTA,cAAsB,SAKtBA,uBAA+B,QAK/BA,kBAAyB,MAKzBA,2BAAkC,OAKlCA,qBAAkB,EAMlBA,kBAAe,EAMfA,iBAAc,EAKdA,iBAAc,EAQdA,eAAY,IAEdA,kBAAmC,KAUzCQ,QAAQC,UAAUJ,MAAK,IAAOL,KAAKD,OAASA,GAAUC,KAAKU,gBAC5D,sBARC,MAAO,CACLb,UAAW,WAEd,YAOUE,GACTY,OAAOC,OAAOZ,KAAMW,OAAOC,OAAO,GAAIZ,KAAKU,eAAgBX,GAC5D,cAGC,MAAO,CACLF,UAAWG,KAAKH,UAEnB,kBAOC,YAAYgB,WACb,gBACcC,GACb,QAAaC,OAAOD,GAChBE,IAAShB,KAAKa,cAChBb,KAAKa,YAAcG,EACnBhB,KAAKiB,kBAER,iBAMC,YAAYC,UACb,eACaC,IAEZA,EAAc,eAARA,EAAuBA,EAAM,cACvBnB,KAAKkB,aACflB,KAAKkB,WAAaC,EAClBnB,KAAKoB,SAAmB,eAARD,EAAuB,QAAU,SACjDnB,KAAKqB,kBAA4B,eAARF,EAAuB,SAAW,QAC3DnB,KAAKsB,aAAuB,eAARH,EAAuB,OAAS,MACpDnB,KAAKuB,sBAAgC,eAARJ,EAAuB,MAAQ,OAC5DnB,KAAKwB,iBAER,oBAMC,YAAYC,aACb,kBACgBC,GACf,MAAMC,UAACA,EAADC,UAAYA,GAAa5B,KAC/BW,OAAOC,OAAOZ,KAAKyB,cAAeC,GAC9BE,IAAc5B,KAAK4B,UAErB5B,KAAK6B,wBACIF,IAAc3B,KAAK2B,WAC5B3B,KAAK8B,kBAER,sBAMC,YAAYC,aACb,oBACkBC,GACjBrB,OAAOC,OAAOZ,KAAK+B,cAAeC,GAClC,QAAehC,KAAKiC,gBACpBjC,KAAKiC,gBAAkBjC,KAAK+B,cAAc/B,KAAKsB,cAC3CY,IAAWlC,KAAKiC,kBAClBjC,KAAKmC,uBAAuBD,EAAQlC,KAAKiC,iBACzCjC,KAAKoC,sBAAsB,CAACC,MAAM,KAEpCrC,KAAK8B,kBACN,CAKDQ,eAAeC,GAAQ,IACjBA,GAASvC,KAAKwC,kBAChBxC,KAAKwC,gBAAiB,EACtBxC,KAAKyC,UAER,CAMDC,cAAcC,EAAeC,EAAW,SACtC,GAAK7B,OAAO8B,SAASF,GAArB,CAMA,OALAA,EAAQG,KAAKC,IAAI/C,KAAKgD,WAAYF,KAAKG,IAAI,EAAGN,IAC9C3C,KAAKkD,eAAiBP,EACL,YAAbC,IACFA,EAAWD,EAAQ3C,KAAKmD,OAASnD,KAAKgB,KAAO,EAAI,MAAQ,SAEnD4B,GACN,IAAK,QACH5C,KAAKoD,gBAAkB,EACvB,MACF,IAAK,SACHpD,KAAKoD,gBAAkB,GACvB,MACF,IAAK,MACHpD,KAAKoD,gBAAkB,EACvB,MACF,QACE,oBACE,wDAGNpD,KAAKiB,kBACN,CAEkBzB,oBAAC6D,cACPC,oBACXtD,KAAKO,aAAcgD,cAAcF,EAClC,CAEqB7D,uBACpBgE,EACAC,EACAC,cAEWJ,oBACXtD,KAAKO,aAAcoD,iBAAiBH,EAAMC,EAAUC,EACrD,CAEwBlE,0BACvBgE,EACAI,EACAF,cAEWJ,oBACXtD,KAAKO,aAAcsD,oBAAoBL,EAAMI,EAAUF,EACxD,CAwBSI,gBAET,iBAUC,YAAYrC,cAAczB,KAAKoB,SAChC,iBAMC,YAAYK,cAAczB,KAAKqB,kBAChC,CAESJ,kBACRjB,KAAKwC,gBAAiB,CACvB,CAESX,wBACR7B,KAAK+D,sBAAuB,EAC5B/D,KAAKiB,iBACN,CAISO,iBACRxB,KAAK6B,wBAKLrB,QAAQC,UAAUJ,MAAK,IAAML,KAAKsC,kBACnC,CAESG,UACJzC,KAAK+D,uBACP/D,KAAK8D,gBACL9D,KAAK+D,sBAAuB,GAE9B/D,KAAKgE,oBACLhE,KAAKiE,kBACLjE,KAAKkE,kBACLlE,KAAKoC,wBACLpC,KAAKmE,kBACLnE,KAAKoE,aACLpE,KAAKqE,sBACLrE,KAAKsE,kBACN,CAESJ,kBACR,IAA6B,IAAzBlE,KAAKkD,eACP,OAEF,QAAclD,KAAKkD,iBACJlD,KAAKoD,kBACRpD,KAAKuE,iBAAiB5B,GAAO3C,KAAKsB,gBACjCtB,KAAKwE,aAAa7B,GAAO3C,KAAKoB,YAEtBpB,KAAKiC,gBAAkBjC,KAAK2B,UAAY8C,IACxCC,EAAMC,EAAOF,IAEX3B,KAAK8B,MAC1B9B,KAAKC,IACH/C,KAAK6E,YAAc7E,KAAK2B,UACxBmB,KAAKG,IAAI,EAAGjD,KAAKiC,gBAAkB6C,EAAeC,KAGtD/E,KAAKgF,cAAgBhF,KAAKiC,gBAAkBgD,EAC5CjF,KAAKiC,gBAAkBgD,CACxB,CAESb,WAAWc,GACnB,QAAevE,OAAOC,OACpB,CACEuE,MAAOnF,KAAKmD,OACZiC,KAAMpF,KAAKqF,MACXvE,IAAKd,KAAKgB,KACVsE,aAActF,KAAKuF,cACnBC,YAAaxF,KAAKyF,cAEpBP,GAEFlF,KAAKuD,cAAc,gBAAgB,cAAe,CAACmC,WACpD,CAESvB,kBACR,QAAe,CACb,CAACnE,KAAKoB,UAAWpB,KAAK6E,YACtB,CAAC7E,KAAKqB,mBAAoB,MAE5BrB,KAAKuD,cAAc,gBAAgB,mBAAoB,CAACmC,WACzD,CAESpB,mBACR,GAAItE,KAAKgF,aAAc,CACrB,QAAe,CACb,CAAChF,KAAKsB,cAAetB,KAAKgF,aAC1B,CAAChF,KAAKuB,uBAAwB,GAEhCvB,KAAKuD,cAAc,gBAAgB,oBAAqB,CAACmC,YACzD1F,KAAKgF,aAAe,CACrB,CACF,CAMSX,sBACR,QAA2C,GAC3C,IAAK,MAAUrE,KAAKmD,OAAQwC,GAAO3F,KAAKqF,MAAOM,IAC7CD,EAAOC,GAAO3F,KAAKuE,iBAAiBoB,GAEtC3F,KAAKuD,cAAc,gBAAgB,qBAAsB,CAACmC,WAC3D,YAMC,OAAqB,IAAjB1F,KAAKmD,SAAiC,IAAhBnD,KAAKqF,aAGnBA,MAAQrF,KAAKmD,OAAS,CACnC,CAEOrB,mBACN,GAAuB,IAAnB9B,KAAK2B,WAAmB3B,KAAKgB,KAAO,EACtChB,KAAKiB,sBACA,CACL,QAAY6B,KAAKG,IAAI,EAAGjD,KAAKiC,gBAAkBjC,KAAK4F,aACxC9C,KAAKC,IACf/C,KAAK6E,YACL7E,KAAKiC,gBAAkBjC,KAAK2B,UAAY3B,KAAK4F,YAE3C5F,KAAK6F,aAAe9C,GAAO/C,KAAK8F,aAAe7C,IACjDjD,KAAKiB,iBAER,CACF,CAMSmB,sBAAsBsB,GAC9B,IAAqB,IAAjB1D,KAAKmD,SAAiC,IAAhBnD,KAAKqF,MAAc,OAE7C,MAAmBrF,KAAKmD,OACxB,KACEmC,EAAetF,KAAKqF,OACpBvC,KAAKiD,MACH/F,KAAKuE,iBAAiBe,GAActF,KAAKsB,cACvCtB,KAAKwE,aAAac,GAActF,KAAKoB,YACpC0B,KAAKiD,MAAM/F,KAAKiC,kBAErBqD,IAGF,MAAkBtF,KAAKqF,MACvB,KACEG,EAAcxF,KAAKmD,QACnBL,KAAKiD,MAAM/F,KAAKuE,iBAAiBiB,GAAaxF,KAAKsB,gBACjDwB,KAAKiD,MAAM/F,KAAKiC,gBAAkBjC,KAAK2B,YAEzC6D,IAIAF,IAAiBtF,KAAKuF,eACtBC,IAAgBxF,KAAKyF,eAErBzF,KAAKuF,cAAgBD,EACrBtF,KAAKyF,aAAeD,EAChB9B,GAAWA,EAAQrB,MACrBrC,KAAKoE,aAGV,CAEOjC,uBAAuBD,EAAgB8D,GAG7C,QAAehG,KAAK6E,YAAc7E,KAAK2B,WACnCO,EAAS+D,GAAUD,EAASC,KAC9BjG,KAAKkD,gBAAkB,EAE1B"}
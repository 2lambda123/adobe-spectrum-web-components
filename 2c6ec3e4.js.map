{"version":3,"file":"2c6ec3e4.js","sources":["../../../node_modules/@lit-labs/virtualizer/layouts/shared/SizeCache.js","../../../node_modules/@lit-labs/virtualizer/layouts/flow.js"],"sourcesContent":["export class SizeCache {\n    constructor(config) {\n        this._map = new Map();\n        this._roundAverageSize = true;\n        this.totalSize = 0;\n        if ((config === null || config === void 0 ? void 0 : config.roundAverageSize) === false) {\n            this._roundAverageSize = false;\n        }\n    }\n    set(index, value) {\n        const prev = this._map.get(index) || 0;\n        this._map.set(index, value);\n        this.totalSize += value - prev;\n    }\n    get averageSize() {\n        if (this._map.size > 0) {\n            const average = this.totalSize / this._map.size;\n            return this._roundAverageSize ? Math.round(average) : average;\n        }\n        return 0;\n    }\n    getSize(index) {\n        return this._map.get(index);\n    }\n    clear() {\n        this._map.clear();\n        this.totalSize = 0;\n    }\n}\n//# sourceMappingURL=SizeCache.js.map","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { SizeCache } from './shared/SizeCache.js';\nimport { BaseLayout, dim1 } from './shared/BaseLayout.js';\nexport const flow = (config) => Object.assign({\n    type: FlowLayout,\n}, config);\nfunction leadingMargin(direction) {\n    return direction === 'horizontal' ? 'marginLeft' : 'marginTop';\n}\nfunction trailingMargin(direction) {\n    return direction === 'horizontal' ? 'marginRight' : 'marginBottom';\n}\nfunction offset(direction) {\n    return direction === 'horizontal' ? 'xOffset' : 'yOffset';\n}\nfunction collapseMargins(a, b) {\n    const m = [a, b].sort();\n    return m[1] <= 0 ? Math.min(...m) : m[0] >= 0 ? Math.max(...m) : m[0] + m[1];\n}\nclass MetricsCache {\n    constructor() {\n        this._childSizeCache = new SizeCache();\n        this._marginSizeCache = new SizeCache();\n        this._metricsCache = new Map();\n    }\n    update(metrics, direction) {\n        var _a, _b;\n        const marginsToUpdate = new Set();\n        Object.keys(metrics).forEach((key) => {\n            const k = Number(key);\n            this._metricsCache.set(k, metrics[k]);\n            this._childSizeCache.set(k, metrics[k][dim1(direction)]);\n            marginsToUpdate.add(k);\n            marginsToUpdate.add(k + 1);\n        });\n        for (const k of marginsToUpdate) {\n            const a = ((_a = this._metricsCache.get(k)) === null || _a === void 0 ? void 0 : _a[leadingMargin(direction)]) || 0;\n            const b = ((_b = this._metricsCache.get(k - 1)) === null || _b === void 0 ? void 0 : _b[trailingMargin(direction)]) || 0;\n            this._marginSizeCache.set(k, collapseMargins(a, b));\n        }\n    }\n    get averageChildSize() {\n        return this._childSizeCache.averageSize;\n    }\n    get totalChildSize() {\n        return this._childSizeCache.totalSize;\n    }\n    get averageMarginSize() {\n        return this._marginSizeCache.averageSize;\n    }\n    get totalMarginSize() {\n        return this._marginSizeCache.totalSize;\n    }\n    getLeadingMarginValue(index, direction) {\n        var _a;\n        return ((_a = this._metricsCache.get(index)) === null || _a === void 0 ? void 0 : _a[leadingMargin(direction)]) || 0;\n    }\n    getChildSize(index) {\n        return this._childSizeCache.getSize(index);\n    }\n    getMarginSize(index) {\n        return this._marginSizeCache.getSize(index);\n    }\n    clear() {\n        this._childSizeCache.clear();\n        this._marginSizeCache.clear();\n        this._metricsCache.clear();\n    }\n}\nexport class FlowLayout extends BaseLayout {\n    constructor() {\n        super(...arguments);\n        /**\n         * Initial estimate of item size\n         */\n        this._itemSize = { width: 100, height: 100 };\n        /**\n         * Indices of children mapped to their (position and length) in the scrolling\n         * direction. Used to keep track of children that are in range.\n         */\n        this._physicalItems = new Map();\n        /**\n         * Used in tandem with _physicalItems to track children in range across\n         * reflows.\n         */\n        this._newPhysicalItems = new Map();\n        /**\n         * Width and height of children by their index.\n         */\n        this._metricsCache = new MetricsCache();\n        /**\n         * anchorIdx is the anchor around which we reflow. It is designed to allow\n         * jumping to any point of the scroll size. We choose it once and stick with\n         * it until stable. _first and _last are deduced around it.\n         */\n        this._anchorIdx = null;\n        /**\n         * Position in the scrolling direction of the anchor child.\n         */\n        this._anchorPos = null;\n        /**\n         * Whether all children in range were in range during the previous reflow.\n         */\n        this._stable = true;\n        this._measureChildren = true;\n        this._estimate = true;\n    }\n    // protected _defaultConfig: BaseLayoutConfig = Object.assign({}, super._defaultConfig, {\n    // })\n    // constructor(config: Layout1dConfig) {\n    //   super(config);\n    // }\n    get measureChildren() {\n        return this._measureChildren;\n    }\n    /**\n     * Determine the average size of all children represented in the sizes\n     * argument.\n     */\n    updateItemSizes(sizes) {\n        this._metricsCache.update(sizes, this.direction);\n        // if (this._nMeasured) {\n        // this._updateItemSize();\n        this._scheduleReflow();\n        // }\n    }\n    /**\n     * Set the average item size based on the total length and number of children\n     * in range.\n     */\n    // _updateItemSize() {\n    //   // Keep integer values.\n    //   this._itemSize[this._sizeDim] = this._metricsCache.averageChildSize;\n    // }\n    _getPhysicalItem(idx) {\n        var _a;\n        return (_a = this._newPhysicalItems.get(idx)) !== null && _a !== void 0 ? _a : this._physicalItems.get(idx);\n    }\n    _getSize(idx) {\n        const item = this._getPhysicalItem(idx);\n        return item && this._metricsCache.getChildSize(idx);\n    }\n    _getAverageSize() {\n        return this._metricsCache.averageChildSize || this._itemSize[this._sizeDim];\n    }\n    /**\n     * Returns the position in the scrolling direction of the item at idx.\n     * Estimates it if the item at idx is not in the DOM.\n     */\n    _getPosition(idx) {\n        var _a;\n        const item = this._getPhysicalItem(idx);\n        const { averageMarginSize } = this._metricsCache;\n        return idx === 0\n            ? (_a = this._metricsCache.getMarginSize(0)) !== null && _a !== void 0 ? _a : averageMarginSize\n            : item\n                ? item.pos\n                : averageMarginSize + idx * (averageMarginSize + this._getAverageSize());\n    }\n    _calculateAnchor(lower, upper) {\n        if (lower <= 0) {\n            return 0;\n        }\n        if (upper > this._scrollSize - this._viewDim1) {\n            return this._totalItems - 1;\n        }\n        return Math.max(0, Math.min(this._totalItems - 1, Math.floor((lower + upper) / 2 / this._delta)));\n    }\n    _getAnchor(lower, upper) {\n        if (this._physicalItems.size === 0) {\n            return this._calculateAnchor(lower, upper);\n        }\n        if (this._first < 0) {\n            console.error('_getAnchor: negative _first');\n            return this._calculateAnchor(lower, upper);\n        }\n        if (this._last < 0) {\n            console.error('_getAnchor: negative _last');\n            return this._calculateAnchor(lower, upper);\n        }\n        const firstItem = this._getPhysicalItem(this._first), lastItem = this._getPhysicalItem(this._last), firstMin = firstItem.pos, lastMin = lastItem.pos, lastMax = lastMin + this._metricsCache.getChildSize(this._last);\n        if (lastMax < lower) {\n            // Window is entirely past physical items, calculate new anchor\n            return this._calculateAnchor(lower, upper);\n        }\n        if (firstMin > upper) {\n            // Window is entirely before physical items, calculate new anchor\n            return this._calculateAnchor(lower, upper);\n        }\n        // Window contains a physical item\n        // Find one, starting with the one that was previously first visible\n        let candidateIdx = this._firstVisible - 1;\n        let cMax = -Infinity;\n        while (cMax < lower) {\n            const candidate = this._getPhysicalItem(++candidateIdx);\n            cMax = candidate.pos + this._metricsCache.getChildSize(candidateIdx);\n        }\n        return candidateIdx;\n    }\n    /**\n     * Updates _first and _last based on items that should be in the current\n     * viewed range.\n     */\n    _getActiveItems() {\n        if (this._viewDim1 === 0 || this._totalItems === 0) {\n            this._clearItems();\n        }\n        else {\n            this._getItems();\n        }\n    }\n    /**\n     * Sets the range to empty.\n     */\n    _clearItems() {\n        this._first = -1;\n        this._last = -1;\n        this._physicalMin = 0;\n        this._physicalMax = 0;\n        const items = this._newPhysicalItems;\n        this._newPhysicalItems = this._physicalItems;\n        this._newPhysicalItems.clear();\n        this._physicalItems = items;\n        this._stable = true;\n    }\n    /*\n     * Updates _first and _last based on items that should be in the given range.\n     */\n    _getItems() {\n        var _a, _b;\n        const items = this._newPhysicalItems;\n        this._stable = true;\n        let lower, upper;\n        // The anchorIdx is the anchor around which we reflow. It is designed to\n        // allow jumping to any point of the scroll size. We choose it once and\n        // stick with it until stable. first and last are deduced around it.\n        // If we have a scrollToIndex, we anchor on the given\n        // index and set the scroll position accordingly\n        if (this._scrollToIndex >= 0) {\n            this._anchorIdx = Math.min(this._scrollToIndex, this._totalItems - 1);\n            this._anchorPos = this._getPosition(this._anchorIdx);\n            this._scrollIfNeeded();\n        }\n        // Determine the lower and upper bounds of the region to be\n        // rendered, relative to the viewport\n        lower = this._scrollPosition - this._overhang; //leadingOverhang;\n        upper = this._scrollPosition + this._viewDim1 + this._overhang; // trailingOverhang;\n        if (upper < 0 || lower > this._scrollSize) {\n            this._clearItems();\n            return;\n        }\n        // If we are scrolling to a specific index or if we are doing another\n        // pass to stabilize a previously started reflow, we will already\n        // have an anchor. If not, establish an anchor now.\n        if (this._anchorIdx === null || this._anchorPos === null) {\n            this._anchorIdx = this._getAnchor(lower, upper);\n            this._anchorPos = this._getPosition(this._anchorIdx);\n        }\n        let anchorSize = this._getSize(this._anchorIdx);\n        if (anchorSize === undefined) {\n            this._stable = false;\n            anchorSize = this._getAverageSize();\n        }\n        const anchorLeadingMargin = (_a = this._metricsCache.getMarginSize(this._anchorIdx)) !== null && _a !== void 0 ? _a : this._metricsCache.averageMarginSize;\n        const anchorTrailingMargin = (_b = this._metricsCache.getMarginSize(this._anchorIdx + 1)) !== null && _b !== void 0 ? _b : this._metricsCache.averageMarginSize;\n        if (this._anchorIdx === 0) {\n            this._anchorPos = anchorLeadingMargin;\n        }\n        if (this._anchorIdx === this._totalItems - 1) {\n            this._anchorPos = this._scrollSize - anchorTrailingMargin - anchorSize;\n        }\n        // Anchor might be outside bounds, so prefer correcting the error and keep\n        // that anchorIdx.\n        let anchorErr = 0;\n        if (this._anchorPos + anchorSize + anchorTrailingMargin < lower) {\n            anchorErr = lower - (this._anchorPos + anchorSize + anchorTrailingMargin);\n        }\n        if (this._anchorPos - anchorLeadingMargin > upper) {\n            anchorErr = upper - (this._anchorPos - anchorLeadingMargin);\n        }\n        if (anchorErr) {\n            this._scrollPosition -= anchorErr;\n            lower -= anchorErr;\n            upper -= anchorErr;\n            this._scrollError += anchorErr;\n        }\n        items.set(this._anchorIdx, { pos: this._anchorPos, size: anchorSize });\n        this._first = this._last = this._anchorIdx;\n        this._physicalMin = this._anchorPos - anchorLeadingMargin;\n        this._physicalMax = this._anchorPos + anchorSize + anchorTrailingMargin;\n        while (this._physicalMin > lower && this._first > 0) {\n            let size = this._getSize(--this._first);\n            if (size === undefined) {\n                this._stable = false;\n                size = this._getAverageSize();\n            }\n            let margin = this._metricsCache.getMarginSize(this._first);\n            if (margin === undefined) {\n                this._stable = false;\n                margin = this._metricsCache.averageMarginSize;\n            }\n            this._physicalMin -= size;\n            const pos = this._physicalMin;\n            items.set(this._first, { pos, size });\n            this._physicalMin -= margin;\n            if (this._stable === false && this._estimate === false) {\n                break;\n            }\n        }\n        while (this._physicalMax < upper && this._last < this._totalItems - 1) {\n            let size = this._getSize(++this._last);\n            if (size === undefined) {\n                this._stable = false;\n                size = this._getAverageSize();\n            }\n            let margin = this._metricsCache.getMarginSize(this._last);\n            if (margin === undefined) {\n                this._stable = false;\n                margin = this._metricsCache.averageMarginSize;\n            }\n            const pos = this._physicalMax;\n            items.set(this._last, { pos, size });\n            this._physicalMax += size + margin;\n            if (!this._stable && !this._estimate) {\n                break;\n            }\n        }\n        // This handles the cases where we were relying on estimated sizes.\n        const extentErr = this._calculateError();\n        if (extentErr) {\n            this._physicalMin -= extentErr;\n            this._physicalMax -= extentErr;\n            this._anchorPos -= extentErr;\n            this._scrollPosition -= extentErr;\n            items.forEach((item) => (item.pos -= extentErr));\n            this._scrollError += extentErr;\n        }\n        if (this._stable) {\n            this._newPhysicalItems = this._physicalItems;\n            this._newPhysicalItems.clear();\n            this._physicalItems = items;\n        }\n    }\n    _calculateError() {\n        if (this._first === 0) {\n            return this._physicalMin;\n        }\n        else if (this._physicalMin <= 0) {\n            return this._physicalMin - this._first * this._delta;\n        }\n        else if (this._last === this._totalItems - 1) {\n            return this._physicalMax - this._scrollSize;\n        }\n        else if (this._physicalMax >= this._scrollSize) {\n            return (this._physicalMax -\n                this._scrollSize +\n                (this._totalItems - 1 - this._last) * this._delta);\n        }\n        return 0;\n    }\n    // TODO: Can this be made to inherit from base, with proper hooks?\n    _reflow() {\n        const { _first, _last, _scrollSize } = this;\n        this._updateScrollSize();\n        this._getActiveItems();\n        if (this._scrollSize !== _scrollSize) {\n            this._emitScrollSize();\n        }\n        this._updateVisibleIndices();\n        this._emitRange();\n        if (this._first === -1 && this._last === -1) {\n            this._resetReflowState();\n        }\n        else if (this._first !== _first || this._last !== _last) {\n            this._emitChildPositions();\n            this._emitScrollError();\n        }\n        else {\n            this._emitChildPositions();\n            this._emitScrollError();\n            this._resetReflowState();\n        }\n    }\n    _resetReflowState() {\n        this._anchorIdx = null;\n        this._anchorPos = null;\n        this._stable = true;\n    }\n    _updateScrollSize() {\n        const { averageMarginSize } = this._metricsCache;\n        this._scrollSize = Math.max(1, this._totalItems * (averageMarginSize + this._getAverageSize()) +\n            averageMarginSize);\n    }\n    /**\n     * Returns the average size (precise or estimated) of an item in the scrolling direction,\n     * including any surrounding space.\n     */\n    get _delta() {\n        const { averageMarginSize } = this._metricsCache;\n        return this._getAverageSize() + averageMarginSize;\n    }\n    /**\n     * Returns the top and left positioning of the item at idx.\n     */\n    _getItemPosition(idx) {\n        var _a;\n        return {\n            [this._positionDim]: this._getPosition(idx),\n            [this._secondaryPositionDim]: 0,\n            [offset(this.direction)]: -((_a = this._metricsCache.getLeadingMarginValue(idx, this.direction)) !== null && _a !== void 0 ? _a : this._metricsCache.averageMarginSize),\n        };\n    }\n    /**\n     * Returns the height and width of the item at idx.\n     */\n    _getItemSize(idx) {\n        var _a;\n        return {\n            [this._sizeDim]: (this._getSize(idx) || this._getAverageSize()) +\n                ((_a = this._metricsCache.getMarginSize(idx + 1)) !== null && _a !== void 0 ? _a : this._metricsCache.averageMarginSize),\n            [this._secondarySizeDim]: this._itemSize[this._secondarySizeDim],\n        };\n    }\n    _viewDim2Changed() {\n        this._scheduleReflow();\n    }\n}\n//# sourceMappingURL=flow.js.map"],"names":["constructor","config","this","roundAverageSize","_roundAverageSize","set","index","value","_map","get","totalSize","prev","size","Math","round","average","getSize","clear","flow","Object","assign","type","FlowLayout","direction","a","b","sort","min","m","max","update","metrics","keys","forEach","key","Number","_metricsCache","k","_childSizeCache","dim1","marginsToUpdate","add","_a","leadingMargin","_b","trailingMargin","_marginSizeCache","collapseMargins","averageSize","getLeadingMarginValue","getChildSize","getMarginSize","width","height","_measureChildren","updateItemSizes","sizes","_scheduleReflow","_getPhysicalItem","idx","_newPhysicalItems","_physicalItems","_getSize","_getAverageSize","averageChildSize","_itemSize","_sizeDim","_getPosition","averageMarginSize","item","pos","_calculateAnchor","lower","upper","_scrollSize","_viewDim1","_totalItems","floor","_delta","_getAnchor","_first","console","error","_last","lastItem","firstMin","firstItem","_firstVisible","Infinity","cMax","candidateIdx","_getActiveItems","_clearItems","_getItems","_physicalMin","_physicalMax","items","_stable","_scrollToIndex","_anchorIdx","_anchorPos","_scrollIfNeeded","_scrollPosition","_overhang","undefined","anchorSize","anchorLeadingMargin","anchorTrailingMargin","anchorErr","_scrollError","margin","_estimate","_calculateError","extentErr","_reflow","_updateScrollSize","_emitScrollSize","_updateVisibleIndices","_emitRange","_resetReflowState","_emitChildPositions","_emitScrollError","_getItemPosition","_positionDim","_secondaryPositionDim","_getItemSize","_secondarySizeDim","_viewDim2Changed"],"mappings":"iDASEA,YAAYC,GAJJC,UAAqC,QACrCA,wBAAoB,EAC5BA,eAAY,GAGuB,kBAAvB,IAAEC,oBACVD,KAAKE,mBAAoB,EAE5B,CAEDC,IAAIC,EAAwBC,GAC1B,QAAaL,KAAKM,KAAKC,IAAIH,IAAU,EACrCJ,KAAKM,KAAKH,IAAIC,EAAOC,GACrBL,KAAKQ,WAAaH,EAAQI,CAC3B,mBAGC,GAAIT,KAAKM,KAAKI,KAAO,EAAG,CACtB,QAAgBV,KAAKQ,UAAYR,KAAKM,KAAKI,KAC3C,YAAYR,kBAAoBS,KAAKC,MAAMC,GAAWA,CACvD,CACD,QACD,CAEDC,QAAQV,GACN,YAAYE,KAAKC,IAAIH,EACtB,CAEDW,QACEf,KAAKM,KAAKS,QACVf,KAAKQ,UAAY,CAClB,ECAUQ,QAAoCjB,GAC/CkB,OAAOC,OACL,CACEC,KAAMC,GAERrB,GAGJ,WAAuBsB,GACrB,MAAqB,iBAAe,aAAe,WACpD,CAED,WAAwBA,GACtB,MAAqB,iBAAe,cAAgB,cACrD,CAMD,WAAyBC,EAAWC,GAClC,QAAU,CAACD,EAAGC,GAAGC,OACjB,SAAS,IAAM,EAAIb,KAAKc,OAAOC,GAAKA,EAAE,IAAM,EAAIf,KAAKgB,OAAOD,GAAKA,EAAE,GAAKA,EAAE,EAC3E,CAED,QAAA5B,cACUE,qBAAkB,MAClBA,sBAAmB,MACnBA,mBAA6C,OAmDtD,CAjDC4B,OAAOC,EAA0CR,WAC/C,QAAqC,QACrCJ,OAAOa,KAAKD,GAASE,SAASC,IAC5B,QAAUC,OAAOD,GACjBhC,KAAKkC,cAAc/B,IAAIgC,EAAGN,EAAQM,IAClCnC,KAAKoC,gBAAgBjC,IAAIgC,EAAGN,EAAQM,GAAGE,EAAKhB,KAC5CiB,EAAgBC,IAAIJ,GACpBG,EAAgBC,IAAIJ,EAAI,MAE1B,IAAK,aAA4B,CAC/B,SAAmC,eAApBD,cAAc3B,IAAI4B,cAAEK,OAAA,EAAAA,EAAGC,EAAcpB,MAAe,KAC5B,eAAxBa,cAAc3B,IAAI4B,EAAI,cAAEO,OAAA,EAAAA,EAAGC,EAAetB,MAAe,EACxErB,KAAK4C,iBAAiBzC,IAAIgC,EAAGU,EAAgBvB,EAAGC,GACjD,CACF,wBAGC,YAAYa,gBAAgBU,WAC7B,sBAGC,YAAYV,gBAAgB5B,SAC7B,yBAGC,YAAYoC,iBAAiBE,WAC9B,uBAGC,YAAYF,iBAAiBpC,SAC9B,CAEDuC,sBAAsB3C,EAAeiB,SACnC,OAAoC,eAAxBa,cAAc3B,IAAIH,cAAMoC,OAAA,EAAAA,EAAGC,EAAcpB,MAAe,CACrE,CAED2B,aAAa5C,GACX,YAAYgC,gBAAgBtB,QAAQV,EACrC,CAED6C,cAAc7C,GACZ,YAAYwC,iBAAiB9B,QAAQV,EACtC,CAEDW,QACEf,KAAKoC,gBAAgBrB,QACrBf,KAAK4C,iBAAiB7B,QACtBf,KAAKkC,cAAcnB,OACpB,oBAGHjB,kCAIEE,eAAkB,CAACkD,MAAO,IAAKC,OAAQ,KAMvCnD,oBAA0C,QAM1CA,uBAA6C,QAK7CA,mBAAgB,MAOhBA,gBAA4B,KAK5BA,gBAA4B,KAK5BA,cAAU,EAEFA,uBAAmB,EAE3BA,gBAAY,CA4Xb,uBAjXG,YAAYoD,gBACb,CAMDC,gBAAgBC,GACdtD,KAAKkC,cAAcN,OAAO0B,EAAyBtD,KAAKqB,WAGxDrB,KAAKuD,iBAEN,CAWDC,iBAAiBC,SACf,OAAsC,eAA1BC,kBAAkBnD,IAAIkD,cAAIjB,EAAAA,EAAIxC,KAAK2D,eAAepD,IAAIkD,EACnE,CAEDG,SAASH,GAEP,OADazD,KAAKwD,iBAAiBC,IACpBzD,KAAKkC,cAAcc,aAAaS,EAChD,CAEDI,kBACE,YAAY3B,cAAc4B,kBAAoB9D,KAAK+D,UAAU/D,KAAKgE,SACnE,CAMDC,aAAaR,SACX,QAAazD,KAAKwD,iBAAiBC,IAC7BS,kBAACA,GAAqBlE,KAAKkC,cACjC,OAAe,MACwB,eAA9BA,cAAce,cAAc,cAAET,EAAAA,EAAI0B,EACvCC,EACAA,EAAKC,IACLF,EAAoBT,GAAOS,EAAoBlE,KAAK6D,kBACzD,CAEDQ,iBAAiBC,EAAeC,GAC9B,OAAID,GAAS,IAGTC,EAAQvE,KAAKwE,YAAcxE,KAAKyE,eACtBC,YAAc,OAEhB/C,IACV,EACAhB,KAAKc,IACHzB,KAAK0E,YAAc,EACnB/D,KAAKgE,OAAOL,EAAQC,GAAS,EAAIvE,KAAK4E,SAG3C,CAEDC,WAAWP,EAAeC,GACxB,GAAiC,IAA7BvE,KAAK2D,eAAejD,KACtB,YAAY2D,iBAAiBC,EAAOC,GAEtC,GAAIvE,KAAK8E,OAAS,EAEhB,OADAC,QAAQC,MAAM,oCACFX,iBAAiBC,EAAOC,GAEtC,GAAIvE,KAAKiF,MAAQ,EAEf,OADAF,QAAQC,MAAM,mCACFX,iBAAiBC,EAAOC,GAGtC,QAAkBvE,KAAKwD,iBAAiBxD,KAAK8E,QAC3CI,EAAWlF,KAAKwD,iBAAiBxD,KAAKiF,OACtCE,EAAWC,EAAWhB,IAIxB,GAHYc,EAAUd,IACApE,KAAKkC,cAAcc,aAAahD,KAAKiF,OAE7CX,EAEZ,YAAYD,iBAAiBC,EAAOC,GAEtC,GAAIY,EAAWZ,EAEb,YAAYF,iBAAiBC,EAAOC,GAItC,MAAmBvE,KAAKqF,cAAgB,KAC5BC,IACZ,KAAOC,EAAOjB,GAAO,CAEnBiB,EADkBvF,KAAKwD,mBAAmBgC,GACxBpB,IAAMpE,KAAKkC,cAAcc,aAAawC,EACzD,CACD,QACD,CAMDC,kBACyB,IAAnBzF,KAAKyE,WAAwC,IAArBzE,KAAK0E,YAC/B1E,KAAK0F,cAEL1F,KAAK2F,WAER,CAKDD,cACE1F,KAAK8E,QAAU,EACf9E,KAAKiF,OAAS,EACdjF,KAAK4F,aAAe,EACpB5F,KAAK6F,aAAe,EACpB,QAAc7F,KAAK0D,kBACnB1D,KAAK0D,kBAAoB1D,KAAK2D,eAC9B3D,KAAK0D,kBAAkB3C,QACvBf,KAAK2D,eAAiBmC,EACtB9F,KAAK+F,SAAU,CAChB,CAKDJ,oBACE,QAAc3F,KAAK0D,kBAEnB,MAAWa,EAmBX,GApBAvE,KAAK+F,SAAU,EASX/F,KAAKgG,gBAAkB,IACzBhG,KAAKiG,WAAatF,KAAKc,IAAIzB,KAAKgG,eAAgBhG,KAAK0E,YAAc,GACnE1E,KAAKkG,WAAalG,KAAKiE,aAAajE,KAAKiG,YACzCjG,KAAKmG,mBAKP7B,EAAQtE,KAAKoG,gBAAkBpG,KAAKqG,UACpC9B,EAAQvE,KAAKoG,gBAAkBpG,KAAKyE,UAAYzE,KAAKqG,UAEjD9B,EAAQ,GAAKD,EAAQtE,KAAKwE,YAE5B,YADAxE,KAAK0F,cAOiB,OAApB1F,KAAKiG,YAA2C,OAApBjG,KAAKkG,aACnClG,KAAKiG,WAAajG,KAAK6E,WAAWP,EAAOC,GACzCvE,KAAKkG,WAAalG,KAAKiE,aAAajE,KAAKiG,aAG3C,MAAiBjG,KAAK4D,SAAS5D,KAAKiG,iBACjBK,IAAfC,IACFvG,KAAK+F,SAAU,EACfQ,EAAavG,KAAK6D,mBAGpB,QACmD,eAA5C3B,cAAce,cAAcjD,KAAKiG,uBAAWzD,EAAAA,EACjDxC,KAAKkC,cAAcgC,oBAEkC,eAAhDhC,cAAce,cAAcjD,KAAKiG,WAAa,cAAEvD,EAAAA,EACrD1C,KAAKkC,cAAcgC,kBAEG,IAApBlE,KAAKiG,aACPjG,KAAKkG,WAAaM,GAGhBxG,KAAKiG,aAAejG,KAAK0E,YAAc,IACzC1E,KAAKkG,WAAalG,KAAKwE,YAAciC,EAAuBF,GAK9D,MAAgB,EAuBhB,IArBIvG,KAAKkG,WAAaK,EAAaE,EAAuBnC,IACxDoC,EAAYpC,GAAStE,KAAKkG,WAAaK,EAAaE,IAGlDzG,KAAKkG,WAAaM,EAAsBjC,IAC1CmC,EAAYnC,GAASvE,KAAKkG,WAAaM,IAGrCE,IACF1G,KAAKoG,iBAAmBM,EACxBpC,GAASoC,EACTnC,GAASmC,EACT1G,KAAK2G,cAAgBD,GAGvBZ,EAAM3F,IAAIH,KAAKiG,WAAY,CAAC7B,IAAKpE,KAAKkG,WAAYxF,KAAM6F,IAExDvG,KAAK8E,OAAS9E,KAAKiF,MAAQjF,KAAKiG,WAChCjG,KAAK4F,aAAe5F,KAAKkG,WAAaM,EACtCxG,KAAK6F,aAAe7F,KAAKkG,WAAaK,EAAaE,EAE5CzG,KAAK4F,aAAetB,GAAStE,KAAK8E,OAAS,GAAG,CACnD,MAAW9E,KAAK4D,WAAW5D,KAAK8E,aACnBwB,IAAT5F,IACFV,KAAK+F,SAAU,EACfrF,EAAOV,KAAK6D,mBAEd,MAAa7D,KAAKkC,cAAce,cAAcjD,KAAK8E,aACpCwB,IAAXM,IACF5G,KAAK+F,SAAU,EACfa,EAAS5G,KAAKkC,cAAcgC,mBAE9BlE,KAAK4F,cAAgBlF,EACrB,QAAYV,KAAK4F,aAGjB,GAFAE,EAAM3F,IAAIH,KAAK8E,OAAQ,CAACV,MAAK1D,SAC7BV,KAAK4F,cAAgBgB,GACA,IAAjB5G,KAAK+F,UAAwC,IAAnB/F,KAAK6G,UACjC,KAEH,CAED,KAAO7G,KAAK6F,aAAetB,GAASvE,KAAKiF,MAAQjF,KAAK0E,YAAc,GAAG,CACrE,MAAW1E,KAAK4D,WAAW5D,KAAKiF,YACnBqB,IAAT5F,IACFV,KAAK+F,SAAU,EACfrF,EAAOV,KAAK6D,mBAEd,MAAa7D,KAAKkC,cAAce,cAAcjD,KAAKiF,YACpCqB,IAAXM,IACF5G,KAAK+F,SAAU,EACfa,EAAS5G,KAAKkC,cAAcgC,mBAE9B,QAAYlE,KAAK6F,aAGjB,GAFAC,EAAM3F,IAAIH,KAAKiF,MAAO,CAACb,MAAK1D,SAC5BV,KAAK6F,cAAgBnF,EAAOkG,GACvB5G,KAAK+F,UAAY/F,KAAK6G,UACzB,KAEH,CAGD,QAAkB7G,KAAK8G,kBACnBC,IACF/G,KAAK4F,cAAgBmB,EACrB/G,KAAK6F,cAAgBkB,EACrB/G,KAAKkG,YAAca,EACnB/G,KAAKoG,iBAAmBW,EACxBjB,EAAM/D,SAASoC,GAAUA,EAAKC,KAAO2C,IACrC/G,KAAK2G,cAAgBI,GAGnB/G,KAAK+F,UACP/F,KAAK0D,kBAAoB1D,KAAK2D,eAC9B3D,KAAK0D,kBAAkB3C,QACvBf,KAAK2D,eAAiBmC,EAEzB,CAEDgB,kBACE,OAAoB,IAAhB9G,KAAK8E,YACKc,aACH5F,KAAK4F,cAAgB,OAClBA,aAAe5F,KAAK8E,OAAS9E,KAAK4E,OACrC5E,KAAKiF,QAAUjF,KAAK0E,YAAc,OAC/BmB,aAAe7F,KAAKwE,YACvBxE,KAAK6F,cAAgB7F,KAAKwE,iBAE5BqB,aACL7F,KAAKwE,aACJxE,KAAK0E,YAAc,EAAI1E,KAAKiF,OAASjF,KAAK4E,QAIhD,CAGDoC,UACE,MAAMlC,OAACA,EAADG,MAASA,EAATT,YAAgBA,GAAexE,KAErCA,KAAKiH,oBACLjH,KAAKyF,kBAEDzF,KAAKwE,cAAgBA,GACvBxE,KAAKkH,kBAGPlH,KAAKmH,wBACLnH,KAAKoH,cACgB,IAAjBpH,KAAK8E,SAAiC,IAAhB9E,KAAKiF,MAC7BjF,KAAKqH,oBACIrH,KAAK8E,SAAWA,GAAU9E,KAAKiF,QAAUA,GAClDjF,KAAKsH,sBACLtH,KAAKuH,qBAELvH,KAAKsH,sBACLtH,KAAKuH,mBACLvH,KAAKqH,oBAER,CAEDA,oBACErH,KAAKiG,WAAa,KAClBjG,KAAKkG,WAAa,KAClBlG,KAAK+F,SAAU,CAChB,CAEDkB,oBACE,MAAM/C,kBAACA,GAAqBlE,KAAKkC,cACjClC,KAAKwE,YAAc7D,KAAKgB,IACtB,EACA3B,KAAK0E,aAAeR,EAAoBlE,KAAK6D,mBAC3CK,EAEL,cAOC,MAAMA,kBAACA,GAAqBlE,KAAKkC,cACjC,YAAY2B,kBAAoBK,CACjC,CAKDsD,iBAAiB/D,SA5cHpC,EA6cZ,MAAO,CACL,CAACrB,KAAKyH,cAAezH,KAAKiE,aAAaR,GACvC,CAACzD,KAAK0H,uBAAwB,EAC9B,EAhdUrG,EAgdFrB,KAAKqB,UA/cI,iBAAe,UAAY,cAgdmB,eAAxDa,cAAca,sBAAsBU,EAAKzD,KAAKqB,sBAAUmB,EAAAA,EAC7DxC,KAAKkC,cAAcgC,mBAGxB,CAKDyD,aAAalE,SACX,MAAO,CACL,CAACzD,KAAKgE,WACHhE,KAAK4D,SAASH,IAAQzD,KAAK6D,oBACc,eAApC3B,cAAce,cAAcQ,EAAM,cAAEjB,EAAAA,EACxCxC,KAAKkC,cAAcgC,mBACvB,CAAClE,KAAK4H,mBAAoB5H,KAAK+D,UAAU/D,KAAK4H,mBAEjD,CAEDC,mBACE7H,KAAKuD,iBACN"}